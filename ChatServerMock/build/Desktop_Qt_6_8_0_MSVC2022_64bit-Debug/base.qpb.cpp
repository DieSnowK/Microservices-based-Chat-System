/* This file is autogenerated. DO NOT CHANGE. All changes will be lost */


#include "base.qpb.h"

#include <QtProtobuf/qprotobufregistration.h>

#include <cmath>

namespace SnowK {
static QtProtobuf::ProtoTypeRegistrar ProtoTypeRegistrarMessageTypeGadget(MessageTypeGadget::registerTypes);
void MessageTypeGadget::registerTypes()
{
    qRegisterMetaType<MessageType>();
    qRegisterMetaType<SnowK::MessageTypeGadget::MessageType>();
    qRegisterProtobufEnumType<SnowK::MessageTypeGadget::MessageType>();
}


class UserInfo_QtProtobufData : public QSharedData
{
public:
    UserInfo_QtProtobufData()
        : QSharedData()
    {
    }

    UserInfo_QtProtobufData(const UserInfo_QtProtobufData &other)
        : QSharedData(other),
          m_userId(other.m_userId),
          m_nickname(other.m_nickname),
          m_description(other.m_description),
          m_phone(other.m_phone),
          m_avatar(other.m_avatar)
    {
    }

    QString m_userId;
    QString m_nickname;
    QString m_description;
    QString m_phone;
    QByteArray m_avatar;
};

UserInfo::~UserInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 21> qt_protobuf_UserInfo_uint_data;
    const char qt_protobuf_UserInfo_char_data[57];
} qt_protobuf_UserInfo_metadata {
    // data
    {
        0, /* = version */
        5, /* = num fields */
        6, /* = field number offset */
        11, /* = property index offset */
        16, /* = field flags offset */
        14, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        15, /* = userId */
        22, /* = nickname */
        31, /* = description */
        43, /* = phone */
        49, /* = avatar */
        56, /* = end-of-string-marker */
        // Field numbers:
        1, /* = userId */
        2, /* = nickname */
        3, /* = description */
        4, /* = phone */
        5, /* = avatar */
        // Property indices:
        0, /* = userId */
        1, /* = nickname */
        2, /* = description */
        3, /* = phone */
        4, /* = avatar */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = userId */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = nickname */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = description */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = phone */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = avatar */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.UserInfo\0" /* = full message name */
    /* field char_data: */
    "userId\0nickname\0description\0phone\0avatar\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering UserInfo::staticPropertyOrdering = {
    &qt_protobuf_UserInfo_metadata.data
};

void UserInfo::registerTypes()
{
    qRegisterMetaType<UserInfo>();
    qRegisterMetaType<UserInfoRepeated>();
}

UserInfo::UserInfo()
    : QProtobufMessage(&UserInfo::staticMetaObject, &UserInfo::staticPropertyOrdering),
      dptr(new UserInfo_QtProtobufData)
{
}

UserInfo::UserInfo(const UserInfo &other)
    = default;
UserInfo &UserInfo::operator =(const UserInfo &other)
{
    UserInfo temp(other);
    swap(temp);
    return *this;
}
UserInfo::UserInfo(UserInfo &&other) noexcept
    = default;
bool comparesEqual(const UserInfo &lhs, const UserInfo &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_userId == rhs.dptr->m_userId
        && lhs.dptr->m_nickname == rhs.dptr->m_nickname
        && lhs.dptr->m_description == rhs.dptr->m_description
        && lhs.dptr->m_phone == rhs.dptr->m_phone
        && lhs.dptr->m_avatar == rhs.dptr->m_avatar;
}

const QString &UserInfo::userId() const &
{
    return dptr->m_userId;
}

const QString &UserInfo::nickname() const &
{
    return dptr->m_nickname;
}

const QString &UserInfo::description() const &
{
    return dptr->m_description;
}

const QString &UserInfo::phone() const &
{
    return dptr->m_phone;
}

const QByteArray &UserInfo::avatar() const &
{
    return dptr->m_avatar;
}

void UserInfo::setUserId(const QString &userId)
{
    if (dptr->m_userId != userId) {
        dptr.detach();
        dptr->m_userId = userId;
    }
}

void UserInfo::setUserId(QString &&userId)
{
    if (dptr->m_userId != userId) {
        dptr.detach();
        dptr->m_userId = std::move(userId);
    }
}

void UserInfo::setNickname(const QString &nickname)
{
    if (dptr->m_nickname != nickname) {
        dptr.detach();
        dptr->m_nickname = nickname;
    }
}

void UserInfo::setNickname(QString &&nickname)
{
    if (dptr->m_nickname != nickname) {
        dptr.detach();
        dptr->m_nickname = std::move(nickname);
    }
}

void UserInfo::setDescription(const QString &description)
{
    if (dptr->m_description != description) {
        dptr.detach();
        dptr->m_description = description;
    }
}

void UserInfo::setDescription(QString &&description)
{
    if (dptr->m_description != description) {
        dptr.detach();
        dptr->m_description = std::move(description);
    }
}

void UserInfo::setPhone(const QString &phone)
{
    if (dptr->m_phone != phone) {
        dptr.detach();
        dptr->m_phone = phone;
    }
}

void UserInfo::setPhone(QString &&phone)
{
    if (dptr->m_phone != phone) {
        dptr.detach();
        dptr->m_phone = std::move(phone);
    }
}

void UserInfo::setAvatar(const QByteArray &avatar)
{
    if (dptr->m_avatar != avatar) {
        dptr.detach();
        dptr->m_avatar = avatar;
    }
}

void UserInfo::setAvatar(QByteArray &&avatar)
{
    if (dptr->m_avatar != avatar) {
        dptr.detach();
        dptr->m_avatar = std::move(avatar);
    }
}


class ChatSessionInfo_QtProtobufData : public QSharedData
{
public:
    ChatSessionInfo_QtProtobufData()
        : QSharedData(),
          m_prevMessage(nullptr)
    {
    }

    ChatSessionInfo_QtProtobufData(const ChatSessionInfo_QtProtobufData &other)
        : QSharedData(other),
          m_singleChatFriendId(other.m_singleChatFriendId),
          m_chatSessionId(other.m_chatSessionId),
          m_chatSessionName(other.m_chatSessionName),
          m_prevMessage(other.m_prevMessage
                                               ? new MessageInfo(*other.m_prevMessage)
                                               : nullptr),
          m_avatar(other.m_avatar)
    {
    }

    std::optional<QString> m_singleChatFriendId;
    QString m_chatSessionId;
    QString m_chatSessionName;
    QtProtobufPrivate::QProtobufLazyMessagePointer<MessageInfo> m_prevMessage;
    std::optional<QByteArray> m_avatar;
};

ChatSessionInfo::~ChatSessionInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 21> qt_protobuf_ChatSessionInfo_uint_data;
    const char qt_protobuf_ChatSessionInfo_char_data[91];
} qt_protobuf_ChatSessionInfo_metadata {
    // data
    {
        0, /* = version */
        5, /* = num fields */
        6, /* = field number offset */
        11, /* = property index offset */
        16, /* = field flags offset */
        21, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        22, /* = singleChatFriendId */
        41, /* = chatSessionId */
        55, /* = chatSessionName */
        71, /* = prevMessage */
        83, /* = avatar */
        90, /* = end-of-string-marker */
        // Field numbers:
        1, /* = singleChatFriendId */
        2, /* = chatSessionId */
        3, /* = chatSessionName */
        4, /* = prevMessage */
        5, /* = avatar */
        // Property indices:
        0, /* = singleChatFriendId */
        2, /* = chatSessionId */
        3, /* = chatSessionName */
        4, /* = prevMessage */
        6, /* = avatar */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = singleChatFriendId */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = chatSessionId */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = chatSessionName */
        uint(QtProtobufPrivate::FieldFlag::ExplicitPresence | QtProtobufPrivate::FieldFlag::Message), /* = prevMessage */
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = avatar */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.ChatSessionInfo\0" /* = full message name */
    /* field char_data: */
    "singleChatFriendId\0chatSessionId\0chatSessionName\0prevMessage\0avatar\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering ChatSessionInfo::staticPropertyOrdering = {
    &qt_protobuf_ChatSessionInfo_metadata.data
};

void ChatSessionInfo::registerTypes()
{
    qRegisterMetaType<ChatSessionInfo>();
    qRegisterMetaType<ChatSessionInfoRepeated>();
}

ChatSessionInfo::ChatSessionInfo()
    : QProtobufMessage(&ChatSessionInfo::staticMetaObject, &ChatSessionInfo::staticPropertyOrdering),
      dptr(new ChatSessionInfo_QtProtobufData)
{
}

ChatSessionInfo::ChatSessionInfo(const ChatSessionInfo &other)
    = default;
ChatSessionInfo &ChatSessionInfo::operator =(const ChatSessionInfo &other)
{
    ChatSessionInfo temp(other);
    swap(temp);
    return *this;
}
ChatSessionInfo::ChatSessionInfo(ChatSessionInfo &&other) noexcept
    = default;
bool comparesEqual(const ChatSessionInfo &lhs, const ChatSessionInfo &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_singleChatFriendId == rhs.dptr->m_singleChatFriendId
        && lhs.dptr->m_chatSessionId == rhs.dptr->m_chatSessionId
        && lhs.dptr->m_chatSessionName == rhs.dptr->m_chatSessionName
        && (lhs.dptr->m_prevMessage == rhs.dptr->m_prevMessage
            || *lhs.dptr->m_prevMessage == *rhs.dptr->m_prevMessage)
        && lhs.dptr->m_avatar == rhs.dptr->m_avatar;
}

QString ChatSessionInfo::singleChatFriendId_p() const
{
    return dptr->m_singleChatFriendId ?
        dptr->m_singleChatFriendId.value() : QString();
}

bool ChatSessionInfo::hasSingleChatFriendId() const
{
    return dptr->m_singleChatFriendId.has_value();
}
QString ChatSessionInfo::singleChatFriendId() const
{
    Q_ASSERT(dptr->m_singleChatFriendId.has_value());
    return dptr->m_singleChatFriendId.value();
}

const QString &ChatSessionInfo::chatSessionId() const &
{
    return dptr->m_chatSessionId;
}

const QString &ChatSessionInfo::chatSessionName() const &
{
    return dptr->m_chatSessionName;
}

MessageInfo *ChatSessionInfo::prevMessage_p()
{
    if (!dptr->m_prevMessage)
        dptr.detach();
    return dptr->m_prevMessage.get();
}

bool ChatSessionInfo::hasPrevMessage() const
{
    return dptr->m_prevMessage.operator bool();
}

const MessageInfo &ChatSessionInfo::prevMessage() const &
{
    return *dptr->m_prevMessage;
}

void ChatSessionInfo::clearPrevMessage()
{
    if (dptr->m_prevMessage) {
        dptr.detach();
        dptr->m_prevMessage.reset();
    }
}

QByteArray ChatSessionInfo::avatar_p() const
{
    return dptr->m_avatar ?
        dptr->m_avatar.value() : QByteArray();
}

bool ChatSessionInfo::hasAvatar() const
{
    return dptr->m_avatar.has_value();
}
QByteArray ChatSessionInfo::avatar() const
{
    Q_ASSERT(dptr->m_avatar.has_value());
    return dptr->m_avatar.value();
}

void ChatSessionInfo::setSingleChatFriendId(const QString &singleChatFriendId)
{
    if (!dptr->m_singleChatFriendId || dptr->m_singleChatFriendId.value() != singleChatFriendId) {
        dptr.detach();
        dptr->m_singleChatFriendId = singleChatFriendId;
    }
}

void ChatSessionInfo::setSingleChatFriendId(QString &&singleChatFriendId)
{
    if (!dptr->m_singleChatFriendId || dptr->m_singleChatFriendId.value() != singleChatFriendId) {
        dptr.detach();
        dptr->m_singleChatFriendId = std::move(singleChatFriendId);
    }
}

void ChatSessionInfo::setSingleChatFriendId_p(QString singleChatFriendId)
{
    if (!dptr->m_singleChatFriendId || dptr->m_singleChatFriendId != singleChatFriendId) {
        dptr.detach();
        dptr->m_singleChatFriendId = singleChatFriendId;
    }
}

void ChatSessionInfo::clearSingleChatFriendId()
{
    if (dptr->m_singleChatFriendId.has_value()) {
        dptr.detach();
        dptr->m_singleChatFriendId.reset();
    }
}
void ChatSessionInfo::setChatSessionId(const QString &chatSessionId)
{
    if (dptr->m_chatSessionId != chatSessionId) {
        dptr.detach();
        dptr->m_chatSessionId = chatSessionId;
    }
}

void ChatSessionInfo::setChatSessionId(QString &&chatSessionId)
{
    if (dptr->m_chatSessionId != chatSessionId) {
        dptr.detach();
        dptr->m_chatSessionId = std::move(chatSessionId);
    }
}

void ChatSessionInfo::setChatSessionName(const QString &chatSessionName)
{
    if (dptr->m_chatSessionName != chatSessionName) {
        dptr.detach();
        dptr->m_chatSessionName = chatSessionName;
    }
}

void ChatSessionInfo::setChatSessionName(QString &&chatSessionName)
{
    if (dptr->m_chatSessionName != chatSessionName) {
        dptr.detach();
        dptr->m_chatSessionName = std::move(chatSessionName);
    }
}

void ChatSessionInfo::setPrevMessage_p(MessageInfo *prevMessage)
{
    if (dptr->m_prevMessage.get() != prevMessage) {
        dptr.detach();
        dptr->m_prevMessage.reset(prevMessage);
    }
}

void ChatSessionInfo::setPrevMessage(const MessageInfo &prevMessage)
{
    if (*dptr->m_prevMessage != prevMessage) {
        dptr.detach();
        *dptr->m_prevMessage = prevMessage;
    }
}

void ChatSessionInfo::setPrevMessage(MessageInfo &&prevMessage)
{
    if (*dptr->m_prevMessage != prevMessage) {
        dptr.detach();
        *dptr->m_prevMessage = std::move(prevMessage);
    }
}

void ChatSessionInfo::setAvatar(const QByteArray &avatar)
{
    if (!dptr->m_avatar || dptr->m_avatar.value() != avatar) {
        dptr.detach();
        dptr->m_avatar = avatar;
    }
}

void ChatSessionInfo::setAvatar(QByteArray &&avatar)
{
    if (!dptr->m_avatar || dptr->m_avatar.value() != avatar) {
        dptr.detach();
        dptr->m_avatar = std::move(avatar);
    }
}

void ChatSessionInfo::setAvatar_p(QByteArray avatar)
{
    if (!dptr->m_avatar || dptr->m_avatar != avatar) {
        dptr.detach();
        dptr->m_avatar = avatar;
    }
}

void ChatSessionInfo::clearAvatar()
{
    if (dptr->m_avatar.has_value()) {
        dptr.detach();
        dptr->m_avatar.reset();
    }
}

class StringMessageInfo_QtProtobufData : public QSharedData
{
public:
    StringMessageInfo_QtProtobufData()
        : QSharedData()
    {
    }

    StringMessageInfo_QtProtobufData(const StringMessageInfo_QtProtobufData &other)
        : QSharedData(other),
          m_content(other.m_content)
    {
    }

    QString m_content;
};

StringMessageInfo::~StringMessageInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 5> qt_protobuf_StringMessageInfo_uint_data;
    const char qt_protobuf_StringMessageInfo_char_data[33];
} qt_protobuf_StringMessageInfo_metadata {
    // data
    {
        0, /* = version */
        1, /* = num fields */
        2, /* = field number offset */
        3, /* = property index offset */
        4, /* = field flags offset */
        23, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        24, /* = content */
        32, /* = end-of-string-marker */
        // Field numbers:
        1, /* = content */
        // Property indices:
        0, /* = content */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = content */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.StringMessageInfo\0" /* = full message name */
    /* field char_data: */
    "content\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering StringMessageInfo::staticPropertyOrdering = {
    &qt_protobuf_StringMessageInfo_metadata.data
};

void StringMessageInfo::registerTypes()
{
    qRegisterMetaType<StringMessageInfo>();
    qRegisterMetaType<StringMessageInfoRepeated>();
}

StringMessageInfo::StringMessageInfo()
    : QProtobufMessage(&StringMessageInfo::staticMetaObject, &StringMessageInfo::staticPropertyOrdering),
      dptr(new StringMessageInfo_QtProtobufData)
{
}

StringMessageInfo::StringMessageInfo(const StringMessageInfo &other)
    = default;
StringMessageInfo &StringMessageInfo::operator =(const StringMessageInfo &other)
{
    StringMessageInfo temp(other);
    swap(temp);
    return *this;
}
StringMessageInfo::StringMessageInfo(StringMessageInfo &&other) noexcept
    = default;
bool comparesEqual(const StringMessageInfo &lhs, const StringMessageInfo &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_content == rhs.dptr->m_content;
}

const QString &StringMessageInfo::content() const &
{
    return dptr->m_content;
}

void StringMessageInfo::setContent(const QString &content)
{
    if (dptr->m_content != content) {
        dptr.detach();
        dptr->m_content = content;
    }
}

void StringMessageInfo::setContent(QString &&content)
{
    if (dptr->m_content != content) {
        dptr.detach();
        dptr->m_content = std::move(content);
    }
}


class ImageMessageInfo_QtProtobufData : public QSharedData
{
public:
    ImageMessageInfo_QtProtobufData()
        : QSharedData()
    {
    }

    ImageMessageInfo_QtProtobufData(const ImageMessageInfo_QtProtobufData &other)
        : QSharedData(other),
          m_fileId(other.m_fileId),
          m_imageContent(other.m_imageContent)
    {
    }

    std::optional<QString> m_fileId;
    std::optional<QByteArray> m_imageContent;
};

ImageMessageInfo::~ImageMessageInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 9> qt_protobuf_ImageMessageInfo_uint_data;
    const char qt_protobuf_ImageMessageInfo_char_data[44];
} qt_protobuf_ImageMessageInfo_metadata {
    // data
    {
        0, /* = version */
        2, /* = num fields */
        3, /* = field number offset */
        5, /* = property index offset */
        7, /* = field flags offset */
        22, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        23, /* = fileId */
        30, /* = imageContent */
        43, /* = end-of-string-marker */
        // Field numbers:
        1, /* = fileId */
        2, /* = imageContent */
        // Property indices:
        0, /* = fileId */
        2, /* = imageContent */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = fileId */
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = imageContent */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.ImageMessageInfo\0" /* = full message name */
    /* field char_data: */
    "fileId\0imageContent\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering ImageMessageInfo::staticPropertyOrdering = {
    &qt_protobuf_ImageMessageInfo_metadata.data
};

void ImageMessageInfo::registerTypes()
{
    qRegisterMetaType<ImageMessageInfo>();
    qRegisterMetaType<ImageMessageInfoRepeated>();
}

ImageMessageInfo::ImageMessageInfo()
    : QProtobufMessage(&ImageMessageInfo::staticMetaObject, &ImageMessageInfo::staticPropertyOrdering),
      dptr(new ImageMessageInfo_QtProtobufData)
{
}

ImageMessageInfo::ImageMessageInfo(const ImageMessageInfo &other)
    = default;
ImageMessageInfo &ImageMessageInfo::operator =(const ImageMessageInfo &other)
{
    ImageMessageInfo temp(other);
    swap(temp);
    return *this;
}
ImageMessageInfo::ImageMessageInfo(ImageMessageInfo &&other) noexcept
    = default;
bool comparesEqual(const ImageMessageInfo &lhs, const ImageMessageInfo &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_fileId == rhs.dptr->m_fileId
        && lhs.dptr->m_imageContent == rhs.dptr->m_imageContent;
}

QString ImageMessageInfo::fileId_p() const
{
    return dptr->m_fileId ?
        dptr->m_fileId.value() : QString();
}

bool ImageMessageInfo::hasFileId() const
{
    return dptr->m_fileId.has_value();
}
QString ImageMessageInfo::fileId() const
{
    Q_ASSERT(dptr->m_fileId.has_value());
    return dptr->m_fileId.value();
}

QByteArray ImageMessageInfo::imageContent_p() const
{
    return dptr->m_imageContent ?
        dptr->m_imageContent.value() : QByteArray();
}

bool ImageMessageInfo::hasImageContent() const
{
    return dptr->m_imageContent.has_value();
}
QByteArray ImageMessageInfo::imageContent() const
{
    Q_ASSERT(dptr->m_imageContent.has_value());
    return dptr->m_imageContent.value();
}

void ImageMessageInfo::setFileId(const QString &fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId.value() != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void ImageMessageInfo::setFileId(QString &&fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId.value() != fileId) {
        dptr.detach();
        dptr->m_fileId = std::move(fileId);
    }
}

void ImageMessageInfo::setFileId_p(QString fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void ImageMessageInfo::clearFileId()
{
    if (dptr->m_fileId.has_value()) {
        dptr.detach();
        dptr->m_fileId.reset();
    }
}
void ImageMessageInfo::setImageContent(const QByteArray &imageContent)
{
    if (!dptr->m_imageContent || dptr->m_imageContent.value() != imageContent) {
        dptr.detach();
        dptr->m_imageContent = imageContent;
    }
}

void ImageMessageInfo::setImageContent(QByteArray &&imageContent)
{
    if (!dptr->m_imageContent || dptr->m_imageContent.value() != imageContent) {
        dptr.detach();
        dptr->m_imageContent = std::move(imageContent);
    }
}

void ImageMessageInfo::setImageContent_p(QByteArray imageContent)
{
    if (!dptr->m_imageContent || dptr->m_imageContent != imageContent) {
        dptr.detach();
        dptr->m_imageContent = imageContent;
    }
}

void ImageMessageInfo::clearImageContent()
{
    if (dptr->m_imageContent.has_value()) {
        dptr.detach();
        dptr->m_imageContent.reset();
    }
}

class FileMessageInfo_QtProtobufData : public QSharedData
{
public:
    FileMessageInfo_QtProtobufData()
        : QSharedData()
    {
    }

    FileMessageInfo_QtProtobufData(const FileMessageInfo_QtProtobufData &other)
        : QSharedData(other),
          m_fileId(other.m_fileId),
          m_fileSize(other.m_fileSize),
          m_fileName(other.m_fileName),
          m_fileContents(other.m_fileContents)
    {
    }

    std::optional<QString> m_fileId;
    std::optional<QtProtobuf::int64> m_fileSize;
    std::optional<QString> m_fileName;
    std::optional<QByteArray> m_fileContents;
};

FileMessageInfo::~FileMessageInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 17> qt_protobuf_FileMessageInfo_uint_data;
    const char qt_protobuf_FileMessageInfo_char_data[61];
} qt_protobuf_FileMessageInfo_metadata {
    // data
    {
        0, /* = version */
        4, /* = num fields */
        5, /* = field number offset */
        9, /* = property index offset */
        13, /* = field flags offset */
        21, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        22, /* = fileId */
        29, /* = fileSize */
        38, /* = fileName */
        47, /* = fileContents */
        60, /* = end-of-string-marker */
        // Field numbers:
        1, /* = fileId */
        2, /* = fileSize */
        3, /* = fileName */
        4, /* = fileContents */
        // Property indices:
        0, /* = fileId */
        2, /* = fileSize */
        4, /* = fileName */
        6, /* = fileContents */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = fileId */
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = fileSize */
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = fileName */
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = fileContents */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.FileMessageInfo\0" /* = full message name */
    /* field char_data: */
    "fileId\0fileSize\0fileName\0fileContents\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering FileMessageInfo::staticPropertyOrdering = {
    &qt_protobuf_FileMessageInfo_metadata.data
};

void FileMessageInfo::registerTypes()
{
    qRegisterMetaType<FileMessageInfo>();
    qRegisterMetaType<FileMessageInfoRepeated>();
}

FileMessageInfo::FileMessageInfo()
    : QProtobufMessage(&FileMessageInfo::staticMetaObject, &FileMessageInfo::staticPropertyOrdering),
      dptr(new FileMessageInfo_QtProtobufData)
{
}

FileMessageInfo::FileMessageInfo(const FileMessageInfo &other)
    = default;
FileMessageInfo &FileMessageInfo::operator =(const FileMessageInfo &other)
{
    FileMessageInfo temp(other);
    swap(temp);
    return *this;
}
FileMessageInfo::FileMessageInfo(FileMessageInfo &&other) noexcept
    = default;
bool comparesEqual(const FileMessageInfo &lhs, const FileMessageInfo &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_fileId == rhs.dptr->m_fileId
        && lhs.dptr->m_fileSize == rhs.dptr->m_fileSize
        && lhs.dptr->m_fileName == rhs.dptr->m_fileName
        && lhs.dptr->m_fileContents == rhs.dptr->m_fileContents;
}

QString FileMessageInfo::fileId_p() const
{
    return dptr->m_fileId ?
        dptr->m_fileId.value() : QString();
}

bool FileMessageInfo::hasFileId() const
{
    return dptr->m_fileId.has_value();
}
QString FileMessageInfo::fileId() const
{
    Q_ASSERT(dptr->m_fileId.has_value());
    return dptr->m_fileId.value();
}

QtProtobuf::int64 FileMessageInfo::fileSize_p() const
{
    return dptr->m_fileSize ?
        dptr->m_fileSize.value() : QtProtobuf::int64();
}

bool FileMessageInfo::hasFileSize() const
{
    return dptr->m_fileSize.has_value();
}
QtProtobuf::int64 FileMessageInfo::fileSize() const
{
    Q_ASSERT(dptr->m_fileSize.has_value());
    return dptr->m_fileSize.value();
}

QString FileMessageInfo::fileName_p() const
{
    return dptr->m_fileName ?
        dptr->m_fileName.value() : QString();
}

bool FileMessageInfo::hasFileName() const
{
    return dptr->m_fileName.has_value();
}
QString FileMessageInfo::fileName() const
{
    Q_ASSERT(dptr->m_fileName.has_value());
    return dptr->m_fileName.value();
}

QByteArray FileMessageInfo::fileContents_p() const
{
    return dptr->m_fileContents ?
        dptr->m_fileContents.value() : QByteArray();
}

bool FileMessageInfo::hasFileContents() const
{
    return dptr->m_fileContents.has_value();
}
QByteArray FileMessageInfo::fileContents() const
{
    Q_ASSERT(dptr->m_fileContents.has_value());
    return dptr->m_fileContents.value();
}

void FileMessageInfo::setFileId(const QString &fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId.value() != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void FileMessageInfo::setFileId(QString &&fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId.value() != fileId) {
        dptr.detach();
        dptr->m_fileId = std::move(fileId);
    }
}

void FileMessageInfo::setFileId_p(QString fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void FileMessageInfo::clearFileId()
{
    if (dptr->m_fileId.has_value()) {
        dptr.detach();
        dptr->m_fileId.reset();
    }
}
void FileMessageInfo::setFileSize(QtProtobuf::int64 fileSize)
{
    if (!dptr->m_fileSize || dptr->m_fileSize.value() != fileSize) {
        dptr.detach();
        dptr->m_fileSize = fileSize;
    }
}

void FileMessageInfo::setFileSize_p(QtProtobuf::int64 fileSize)
{
    if (!dptr->m_fileSize || dptr->m_fileSize != fileSize) {
        dptr.detach();
        dptr->m_fileSize = fileSize;
    }
}

void FileMessageInfo::clearFileSize()
{
    if (dptr->m_fileSize.has_value()) {
        dptr.detach();
        dptr->m_fileSize.reset();
    }
}
void FileMessageInfo::setFileName(const QString &fileName)
{
    if (!dptr->m_fileName || dptr->m_fileName.value() != fileName) {
        dptr.detach();
        dptr->m_fileName = fileName;
    }
}

void FileMessageInfo::setFileName(QString &&fileName)
{
    if (!dptr->m_fileName || dptr->m_fileName.value() != fileName) {
        dptr.detach();
        dptr->m_fileName = std::move(fileName);
    }
}

void FileMessageInfo::setFileName_p(QString fileName)
{
    if (!dptr->m_fileName || dptr->m_fileName != fileName) {
        dptr.detach();
        dptr->m_fileName = fileName;
    }
}

void FileMessageInfo::clearFileName()
{
    if (dptr->m_fileName.has_value()) {
        dptr.detach();
        dptr->m_fileName.reset();
    }
}
void FileMessageInfo::setFileContents(const QByteArray &fileContents)
{
    if (!dptr->m_fileContents || dptr->m_fileContents.value() != fileContents) {
        dptr.detach();
        dptr->m_fileContents = fileContents;
    }
}

void FileMessageInfo::setFileContents(QByteArray &&fileContents)
{
    if (!dptr->m_fileContents || dptr->m_fileContents.value() != fileContents) {
        dptr.detach();
        dptr->m_fileContents = std::move(fileContents);
    }
}

void FileMessageInfo::setFileContents_p(QByteArray fileContents)
{
    if (!dptr->m_fileContents || dptr->m_fileContents != fileContents) {
        dptr.detach();
        dptr->m_fileContents = fileContents;
    }
}

void FileMessageInfo::clearFileContents()
{
    if (dptr->m_fileContents.has_value()) {
        dptr.detach();
        dptr->m_fileContents.reset();
    }
}

class SpeechMessageInfo_QtProtobufData : public QSharedData
{
public:
    SpeechMessageInfo_QtProtobufData()
        : QSharedData()
    {
    }

    SpeechMessageInfo_QtProtobufData(const SpeechMessageInfo_QtProtobufData &other)
        : QSharedData(other),
          m_fileId(other.m_fileId),
          m_fileContents(other.m_fileContents)
    {
    }

    std::optional<QString> m_fileId;
    std::optional<QByteArray> m_fileContents;
};

SpeechMessageInfo::~SpeechMessageInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 9> qt_protobuf_SpeechMessageInfo_uint_data;
    const char qt_protobuf_SpeechMessageInfo_char_data[45];
} qt_protobuf_SpeechMessageInfo_metadata {
    // data
    {
        0, /* = version */
        2, /* = num fields */
        3, /* = field number offset */
        5, /* = property index offset */
        7, /* = field flags offset */
        23, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        24, /* = fileId */
        31, /* = fileContents */
        44, /* = end-of-string-marker */
        // Field numbers:
        1, /* = fileId */
        2, /* = fileContents */
        // Property indices:
        0, /* = fileId */
        2, /* = fileContents */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = fileId */
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = fileContents */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.SpeechMessageInfo\0" /* = full message name */
    /* field char_data: */
    "fileId\0fileContents\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering SpeechMessageInfo::staticPropertyOrdering = {
    &qt_protobuf_SpeechMessageInfo_metadata.data
};

void SpeechMessageInfo::registerTypes()
{
    qRegisterMetaType<SpeechMessageInfo>();
    qRegisterMetaType<SpeechMessageInfoRepeated>();
}

SpeechMessageInfo::SpeechMessageInfo()
    : QProtobufMessage(&SpeechMessageInfo::staticMetaObject, &SpeechMessageInfo::staticPropertyOrdering),
      dptr(new SpeechMessageInfo_QtProtobufData)
{
}

SpeechMessageInfo::SpeechMessageInfo(const SpeechMessageInfo &other)
    = default;
SpeechMessageInfo &SpeechMessageInfo::operator =(const SpeechMessageInfo &other)
{
    SpeechMessageInfo temp(other);
    swap(temp);
    return *this;
}
SpeechMessageInfo::SpeechMessageInfo(SpeechMessageInfo &&other) noexcept
    = default;
bool comparesEqual(const SpeechMessageInfo &lhs, const SpeechMessageInfo &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_fileId == rhs.dptr->m_fileId
        && lhs.dptr->m_fileContents == rhs.dptr->m_fileContents;
}

QString SpeechMessageInfo::fileId_p() const
{
    return dptr->m_fileId ?
        dptr->m_fileId.value() : QString();
}

bool SpeechMessageInfo::hasFileId() const
{
    return dptr->m_fileId.has_value();
}
QString SpeechMessageInfo::fileId() const
{
    Q_ASSERT(dptr->m_fileId.has_value());
    return dptr->m_fileId.value();
}

QByteArray SpeechMessageInfo::fileContents_p() const
{
    return dptr->m_fileContents ?
        dptr->m_fileContents.value() : QByteArray();
}

bool SpeechMessageInfo::hasFileContents() const
{
    return dptr->m_fileContents.has_value();
}
QByteArray SpeechMessageInfo::fileContents() const
{
    Q_ASSERT(dptr->m_fileContents.has_value());
    return dptr->m_fileContents.value();
}

void SpeechMessageInfo::setFileId(const QString &fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId.value() != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void SpeechMessageInfo::setFileId(QString &&fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId.value() != fileId) {
        dptr.detach();
        dptr->m_fileId = std::move(fileId);
    }
}

void SpeechMessageInfo::setFileId_p(QString fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void SpeechMessageInfo::clearFileId()
{
    if (dptr->m_fileId.has_value()) {
        dptr.detach();
        dptr->m_fileId.reset();
    }
}
void SpeechMessageInfo::setFileContents(const QByteArray &fileContents)
{
    if (!dptr->m_fileContents || dptr->m_fileContents.value() != fileContents) {
        dptr.detach();
        dptr->m_fileContents = fileContents;
    }
}

void SpeechMessageInfo::setFileContents(QByteArray &&fileContents)
{
    if (!dptr->m_fileContents || dptr->m_fileContents.value() != fileContents) {
        dptr.detach();
        dptr->m_fileContents = std::move(fileContents);
    }
}

void SpeechMessageInfo::setFileContents_p(QByteArray fileContents)
{
    if (!dptr->m_fileContents || dptr->m_fileContents != fileContents) {
        dptr.detach();
        dptr->m_fileContents = fileContents;
    }
}

void SpeechMessageInfo::clearFileContents()
{
    if (dptr->m_fileContents.has_value()) {
        dptr.detach();
        dptr->m_fileContents.reset();
    }
}

class MessageContent_QtProtobufData : public QSharedData
{
public:
    MessageContent_QtProtobufData()
        : QSharedData(),
          m_messageType(MessageTypeGadget::MessageType::STRING)
    {
    }

    MessageContent_QtProtobufData(const MessageContent_QtProtobufData &other)
        : QSharedData(other),
          m_messageType(other.m_messageType),
          m_msg_content(other.m_msg_content)
    {
    }

    MessageTypeGadget::MessageType m_messageType;
    QtProtobufPrivate::QProtobufOneof m_msg_content;
};

MessageContent::~MessageContent() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 21> qt_protobuf_MessageContent_uint_data;
    const char qt_protobuf_MessageContent_char_data[87];
} qt_protobuf_MessageContent_metadata {
    // data
    {
        0, /* = version */
        5, /* = num fields */
        6, /* = field number offset */
        11, /* = property index offset */
        16, /* = field flags offset */
        20, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        21, /* = messageType */
        33, /* = stringMessage */
        47, /* = fileMessage */
        59, /* = speechMessage */
        73, /* = imageMessage */
        86, /* = end-of-string-marker */
        // Field numbers:
        1, /* = messageType */
        2, /* = stringMessage */
        3, /* = fileMessage */
        4, /* = speechMessage */
        5, /* = imageMessage */
        // Property indices:
        0, /* = messageType */
        1, /* = stringMessage */
        3, /* = fileMessage */
        5, /* = speechMessage */
        7, /* = imageMessage */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::Enum), /* = messageType */
        uint(QtProtobufPrivate::FieldFlag::Oneof | QtProtobufPrivate::FieldFlag::ExplicitPresence | QtProtobufPrivate::FieldFlag::Message), /* = stringMessage */
        uint(QtProtobufPrivate::FieldFlag::Oneof | QtProtobufPrivate::FieldFlag::ExplicitPresence | QtProtobufPrivate::FieldFlag::Message), /* = fileMessage */
        uint(QtProtobufPrivate::FieldFlag::Oneof | QtProtobufPrivate::FieldFlag::ExplicitPresence | QtProtobufPrivate::FieldFlag::Message), /* = speechMessage */
        uint(QtProtobufPrivate::FieldFlag::Oneof | QtProtobufPrivate::FieldFlag::ExplicitPresence | QtProtobufPrivate::FieldFlag::Message), /* = imageMessage */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.MessageContent\0" /* = full message name */
    /* field char_data: */
    "messageType\0stringMessage\0fileMessage\0speechMessage\0imageMessage\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering MessageContent::staticPropertyOrdering = {
    &qt_protobuf_MessageContent_metadata.data
};

void MessageContent::registerTypes()
{
    qRegisterMetaType<MessageContent>();
    qRegisterMetaType<MessageContentRepeated>();
}

MessageContent::MessageContent()
    : QProtobufMessage(&MessageContent::staticMetaObject, &MessageContent::staticPropertyOrdering),
      dptr(new MessageContent_QtProtobufData)
{
}

MessageContent::MessageContent(const MessageContent &other)
    = default;
MessageContent &MessageContent::operator =(const MessageContent &other)
{
    MessageContent temp(other);
    swap(temp);
    return *this;
}
MessageContent::MessageContent(MessageContent &&other) noexcept
    = default;
bool comparesEqual(const MessageContent &lhs, const MessageContent &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_messageType == rhs.dptr->m_messageType
        && lhs.dptr->m_msg_content == rhs.dptr->m_msg_content;
}

MessageTypeGadget::MessageType MessageContent::messageType() const
{
    return dptr->m_messageType;
}

StringMessageInfo *MessageContent::stringMessage_p()
{
    if (!dptr->m_msg_content.holdsField(2))
        dptr.detach();
    return dptr->m_msg_content.message<StringMessageInfo>();
}

bool MessageContent::hasStringMessage() const
{
    return dptr->m_msg_content.holdsField(2);
}
StringMessageInfo &MessageContent::stringMessage() const
{
    Q_ASSERT(dptr->m_msg_content.holdsField(2));
    return *(dptr->m_msg_content.message<StringMessageInfo>());
}

FileMessageInfo *MessageContent::fileMessage_p()
{
    if (!dptr->m_msg_content.holdsField(3))
        dptr.detach();
    return dptr->m_msg_content.message<FileMessageInfo>();
}

bool MessageContent::hasFileMessage() const
{
    return dptr->m_msg_content.holdsField(3);
}
FileMessageInfo &MessageContent::fileMessage() const
{
    Q_ASSERT(dptr->m_msg_content.holdsField(3));
    return *(dptr->m_msg_content.message<FileMessageInfo>());
}

SpeechMessageInfo *MessageContent::speechMessage_p()
{
    if (!dptr->m_msg_content.holdsField(4))
        dptr.detach();
    return dptr->m_msg_content.message<SpeechMessageInfo>();
}

bool MessageContent::hasSpeechMessage() const
{
    return dptr->m_msg_content.holdsField(4);
}
SpeechMessageInfo &MessageContent::speechMessage() const
{
    Q_ASSERT(dptr->m_msg_content.holdsField(4));
    return *(dptr->m_msg_content.message<SpeechMessageInfo>());
}

ImageMessageInfo *MessageContent::imageMessage_p()
{
    if (!dptr->m_msg_content.holdsField(5))
        dptr.detach();
    return dptr->m_msg_content.message<ImageMessageInfo>();
}

bool MessageContent::hasImageMessage() const
{
    return dptr->m_msg_content.holdsField(5);
}
ImageMessageInfo &MessageContent::imageMessage() const
{
    Q_ASSERT(dptr->m_msg_content.holdsField(5));
    return *(dptr->m_msg_content.message<ImageMessageInfo>());
}

void MessageContent::setMessageType(MessageTypeGadget::MessageType messageType)
{
    if (dptr->m_messageType != messageType) {
        dptr.detach();
        dptr->m_messageType = messageType;
    }
}

void MessageContent::setStringMessage(const StringMessageInfo &stringMessage)
{
    if (!dptr->m_msg_content.isEqual(stringMessage, 2)) {
        dptr.detach();
        dptr->m_msg_content.setValue(stringMessage, 2);
    }
}

void MessageContent::setStringMessage(StringMessageInfo &&stringMessage)
{
    if (!dptr->m_msg_content.isEqual(stringMessage, 2)) {
        dptr.detach();
        dptr->m_msg_content.setValue(std::move(stringMessage), 2);
    }
}

void MessageContent::setStringMessage_p(StringMessageInfo *stringMessage)
{
    const StringMessageInfo &value = *stringMessage;
    if (!dptr->m_msg_content.isEqual(value, 2)) {
        dptr.detach();
        dptr->m_msg_content.setValue(value, 2);
    }
}

void MessageContent::setFileMessage(const FileMessageInfo &fileMessage)
{
    if (!dptr->m_msg_content.isEqual(fileMessage, 3)) {
        dptr.detach();
        dptr->m_msg_content.setValue(fileMessage, 3);
    }
}

void MessageContent::setFileMessage(FileMessageInfo &&fileMessage)
{
    if (!dptr->m_msg_content.isEqual(fileMessage, 3)) {
        dptr.detach();
        dptr->m_msg_content.setValue(std::move(fileMessage), 3);
    }
}

void MessageContent::setFileMessage_p(FileMessageInfo *fileMessage)
{
    const FileMessageInfo &value = *fileMessage;
    if (!dptr->m_msg_content.isEqual(value, 3)) {
        dptr.detach();
        dptr->m_msg_content.setValue(value, 3);
    }
}

void MessageContent::setSpeechMessage(const SpeechMessageInfo &speechMessage)
{
    if (!dptr->m_msg_content.isEqual(speechMessage, 4)) {
        dptr.detach();
        dptr->m_msg_content.setValue(speechMessage, 4);
    }
}

void MessageContent::setSpeechMessage(SpeechMessageInfo &&speechMessage)
{
    if (!dptr->m_msg_content.isEqual(speechMessage, 4)) {
        dptr.detach();
        dptr->m_msg_content.setValue(std::move(speechMessage), 4);
    }
}

void MessageContent::setSpeechMessage_p(SpeechMessageInfo *speechMessage)
{
    const SpeechMessageInfo &value = *speechMessage;
    if (!dptr->m_msg_content.isEqual(value, 4)) {
        dptr.detach();
        dptr->m_msg_content.setValue(value, 4);
    }
}

void MessageContent::setImageMessage(const ImageMessageInfo &imageMessage)
{
    if (!dptr->m_msg_content.isEqual(imageMessage, 5)) {
        dptr.detach();
        dptr->m_msg_content.setValue(imageMessage, 5);
    }
}

void MessageContent::setImageMessage(ImageMessageInfo &&imageMessage)
{
    if (!dptr->m_msg_content.isEqual(imageMessage, 5)) {
        dptr.detach();
        dptr->m_msg_content.setValue(std::move(imageMessage), 5);
    }
}

void MessageContent::setImageMessage_p(ImageMessageInfo *imageMessage)
{
    const ImageMessageInfo &value = *imageMessage;
    if (!dptr->m_msg_content.isEqual(value, 5)) {
        dptr.detach();
        dptr->m_msg_content.setValue(value, 5);
    }
}

MessageContent::Msg_contentFields MessageContent::msg_contentField() const
{
    return static_cast<Msg_contentFields>(dptr->m_msg_content.fieldNumber());
}
void MessageContent::clearMsg_content()
{
    if (dptr->m_msg_content.fieldNumber() != QtProtobuf::InvalidFieldNumber) {
        dptr.detach();
        dptr->m_msg_content = QtProtobufPrivate::QProtobufOneof();
    }
}

class MessageInfo_QtProtobufData : public QSharedData
{
public:
    MessageInfo_QtProtobufData()
        : QSharedData(),
          m_timestamp(0),
          m_sender(nullptr),
          m_message(nullptr)
    {
    }

    MessageInfo_QtProtobufData(const MessageInfo_QtProtobufData &other)
        : QSharedData(other),
          m_messageId(other.m_messageId),
          m_chatSessionId(other.m_chatSessionId),
          m_timestamp(other.m_timestamp),
          m_sender(other.m_sender
                                               ? new UserInfo(*other.m_sender)
                                               : nullptr),
          m_message(other.m_message
                                               ? new MessageContent(*other.m_message)
                                               : nullptr)
    {
    }

    QString m_messageId;
    QString m_chatSessionId;
    QtProtobuf::int64 m_timestamp;
    QtProtobufPrivate::QProtobufLazyMessagePointer<UserInfo> m_sender;
    QtProtobufPrivate::QProtobufLazyMessagePointer<MessageContent> m_message;
};

MessageInfo::~MessageInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 21> qt_protobuf_MessageInfo_uint_data;
    const char qt_protobuf_MessageInfo_char_data[68];
} qt_protobuf_MessageInfo_metadata {
    // data
    {
        0, /* = version */
        5, /* = num fields */
        6, /* = field number offset */
        11, /* = property index offset */
        16, /* = field flags offset */
        17, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        18, /* = messageId */
        28, /* = chatSessionId */
        42, /* = timestamp */
        52, /* = sender */
        59, /* = message */
        67, /* = end-of-string-marker */
        // Field numbers:
        1, /* = messageId */
        2, /* = chatSessionId */
        3, /* = timestamp */
        4, /* = sender */
        5, /* = message */
        // Property indices:
        0, /* = messageId */
        1, /* = chatSessionId */
        2, /* = timestamp */
        3, /* = sender */
        5, /* = message */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = messageId */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = chatSessionId */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = timestamp */
        uint(QtProtobufPrivate::FieldFlag::ExplicitPresence | QtProtobufPrivate::FieldFlag::Message), /* = sender */
        uint(QtProtobufPrivate::FieldFlag::ExplicitPresence | QtProtobufPrivate::FieldFlag::Message), /* = message */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.MessageInfo\0" /* = full message name */
    /* field char_data: */
    "messageId\0chatSessionId\0timestamp\0sender\0message\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering MessageInfo::staticPropertyOrdering = {
    &qt_protobuf_MessageInfo_metadata.data
};

void MessageInfo::registerTypes()
{
    qRegisterMetaType<MessageInfo>();
    qRegisterMetaType<MessageInfoRepeated>();
}

MessageInfo::MessageInfo()
    : QProtobufMessage(&MessageInfo::staticMetaObject, &MessageInfo::staticPropertyOrdering),
      dptr(new MessageInfo_QtProtobufData)
{
}

MessageInfo::MessageInfo(const MessageInfo &other)
    = default;
MessageInfo &MessageInfo::operator =(const MessageInfo &other)
{
    MessageInfo temp(other);
    swap(temp);
    return *this;
}
MessageInfo::MessageInfo(MessageInfo &&other) noexcept
    = default;
bool comparesEqual(const MessageInfo &lhs, const MessageInfo &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_messageId == rhs.dptr->m_messageId
        && lhs.dptr->m_chatSessionId == rhs.dptr->m_chatSessionId
        && lhs.dptr->m_timestamp == rhs.dptr->m_timestamp
        && (lhs.dptr->m_sender == rhs.dptr->m_sender
            || *lhs.dptr->m_sender == *rhs.dptr->m_sender)
        && (lhs.dptr->m_message == rhs.dptr->m_message
            || *lhs.dptr->m_message == *rhs.dptr->m_message);
}

const QString &MessageInfo::messageId() const &
{
    return dptr->m_messageId;
}

const QString &MessageInfo::chatSessionId() const &
{
    return dptr->m_chatSessionId;
}

QtProtobuf::int64 MessageInfo::timestamp() const
{
    return dptr->m_timestamp;
}

UserInfo *MessageInfo::sender_p()
{
    if (!dptr->m_sender)
        dptr.detach();
    return dptr->m_sender.get();
}

bool MessageInfo::hasSender() const
{
    return dptr->m_sender.operator bool();
}

const UserInfo &MessageInfo::sender() const &
{
    return *dptr->m_sender;
}

void MessageInfo::clearSender()
{
    if (dptr->m_sender) {
        dptr.detach();
        dptr->m_sender.reset();
    }
}

MessageContent *MessageInfo::message_p()
{
    if (!dptr->m_message)
        dptr.detach();
    return dptr->m_message.get();
}

bool MessageInfo::hasMessage() const
{
    return dptr->m_message.operator bool();
}

const MessageContent &MessageInfo::message() const &
{
    return *dptr->m_message;
}

void MessageInfo::clearMessage()
{
    if (dptr->m_message) {
        dptr.detach();
        dptr->m_message.reset();
    }
}

void MessageInfo::setMessageId(const QString &messageId)
{
    if (dptr->m_messageId != messageId) {
        dptr.detach();
        dptr->m_messageId = messageId;
    }
}

void MessageInfo::setMessageId(QString &&messageId)
{
    if (dptr->m_messageId != messageId) {
        dptr.detach();
        dptr->m_messageId = std::move(messageId);
    }
}

void MessageInfo::setChatSessionId(const QString &chatSessionId)
{
    if (dptr->m_chatSessionId != chatSessionId) {
        dptr.detach();
        dptr->m_chatSessionId = chatSessionId;
    }
}

void MessageInfo::setChatSessionId(QString &&chatSessionId)
{
    if (dptr->m_chatSessionId != chatSessionId) {
        dptr.detach();
        dptr->m_chatSessionId = std::move(chatSessionId);
    }
}

void MessageInfo::setTimestamp(QtProtobuf::int64 timestamp)
{
    if (dptr->m_timestamp != timestamp) {
        dptr.detach();
        dptr->m_timestamp = timestamp;
    }
}

void MessageInfo::setSender_p(UserInfo *sender)
{
    if (dptr->m_sender.get() != sender) {
        dptr.detach();
        dptr->m_sender.reset(sender);
    }
}

void MessageInfo::setSender(const UserInfo &sender)
{
    if (*dptr->m_sender != sender) {
        dptr.detach();
        *dptr->m_sender = sender;
    }
}

void MessageInfo::setSender(UserInfo &&sender)
{
    if (*dptr->m_sender != sender) {
        dptr.detach();
        *dptr->m_sender = std::move(sender);
    }
}

void MessageInfo::setMessage_p(MessageContent *message)
{
    if (dptr->m_message.get() != message) {
        dptr.detach();
        dptr->m_message.reset(message);
    }
}

void MessageInfo::setMessage(const MessageContent &message)
{
    if (*dptr->m_message != message) {
        dptr.detach();
        *dptr->m_message = message;
    }
}

void MessageInfo::setMessage(MessageContent &&message)
{
    if (*dptr->m_message != message) {
        dptr.detach();
        *dptr->m_message = std::move(message);
    }
}


class FileDownloadData_QtProtobufData : public QSharedData
{
public:
    FileDownloadData_QtProtobufData()
        : QSharedData()
    {
    }

    FileDownloadData_QtProtobufData(const FileDownloadData_QtProtobufData &other)
        : QSharedData(other),
          m_fileId(other.m_fileId),
          m_fileContent(other.m_fileContent)
    {
    }

    QString m_fileId;
    QByteArray m_fileContent;
};

FileDownloadData::~FileDownloadData() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 9> qt_protobuf_FileDownloadData_uint_data;
    const char qt_protobuf_FileDownloadData_char_data[43];
} qt_protobuf_FileDownloadData_metadata {
    // data
    {
        0, /* = version */
        2, /* = num fields */
        3, /* = field number offset */
        5, /* = property index offset */
        7, /* = field flags offset */
        22, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        23, /* = fileId */
        30, /* = fileContent */
        42, /* = end-of-string-marker */
        // Field numbers:
        1, /* = fileId */
        2, /* = fileContent */
        // Property indices:
        0, /* = fileId */
        1, /* = fileContent */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = fileId */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = fileContent */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.FileDownloadData\0" /* = full message name */
    /* field char_data: */
    "fileId\0fileContent\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering FileDownloadData::staticPropertyOrdering = {
    &qt_protobuf_FileDownloadData_metadata.data
};

void FileDownloadData::registerTypes()
{
    qRegisterMetaType<FileDownloadData>();
    qRegisterMetaType<FileDownloadDataRepeated>();
}

FileDownloadData::FileDownloadData()
    : QProtobufMessage(&FileDownloadData::staticMetaObject, &FileDownloadData::staticPropertyOrdering),
      dptr(new FileDownloadData_QtProtobufData)
{
}

FileDownloadData::FileDownloadData(const FileDownloadData &other)
    = default;
FileDownloadData &FileDownloadData::operator =(const FileDownloadData &other)
{
    FileDownloadData temp(other);
    swap(temp);
    return *this;
}
FileDownloadData::FileDownloadData(FileDownloadData &&other) noexcept
    = default;
bool comparesEqual(const FileDownloadData &lhs, const FileDownloadData &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_fileId == rhs.dptr->m_fileId
        && lhs.dptr->m_fileContent == rhs.dptr->m_fileContent;
}

const QString &FileDownloadData::fileId() const &
{
    return dptr->m_fileId;
}

const QByteArray &FileDownloadData::fileContent() const &
{
    return dptr->m_fileContent;
}

void FileDownloadData::setFileId(const QString &fileId)
{
    if (dptr->m_fileId != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void FileDownloadData::setFileId(QString &&fileId)
{
    if (dptr->m_fileId != fileId) {
        dptr.detach();
        dptr->m_fileId = std::move(fileId);
    }
}

void FileDownloadData::setFileContent(const QByteArray &fileContent)
{
    if (dptr->m_fileContent != fileContent) {
        dptr.detach();
        dptr->m_fileContent = fileContent;
    }
}

void FileDownloadData::setFileContent(QByteArray &&fileContent)
{
    if (dptr->m_fileContent != fileContent) {
        dptr.detach();
        dptr->m_fileContent = std::move(fileContent);
    }
}


class FileUploadData_QtProtobufData : public QSharedData
{
public:
    FileUploadData_QtProtobufData()
        : QSharedData(),
          m_fileSize(0)
    {
    }

    FileUploadData_QtProtobufData(const FileUploadData_QtProtobufData &other)
        : QSharedData(other),
          m_fileName(other.m_fileName),
          m_fileSize(other.m_fileSize),
          m_fileContent(other.m_fileContent)
    {
    }

    QString m_fileName;
    QtProtobuf::int64 m_fileSize;
    QByteArray m_fileContent;
};

FileUploadData::~FileUploadData() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 13> qt_protobuf_FileUploadData_uint_data;
    const char qt_protobuf_FileUploadData_char_data[52];
} qt_protobuf_FileUploadData_metadata {
    // data
    {
        0, /* = version */
        3, /* = num fields */
        4, /* = field number offset */
        7, /* = property index offset */
        10, /* = field flags offset */
        20, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        21, /* = fileName */
        30, /* = fileSize */
        39, /* = fileContent */
        51, /* = end-of-string-marker */
        // Field numbers:
        1, /* = fileName */
        2, /* = fileSize */
        3, /* = fileContent */
        // Property indices:
        0, /* = fileName */
        1, /* = fileSize */
        2, /* = fileContent */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = fileName */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = fileSize */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = fileContent */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.FileUploadData\0" /* = full message name */
    /* field char_data: */
    "fileName\0fileSize\0fileContent\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering FileUploadData::staticPropertyOrdering = {
    &qt_protobuf_FileUploadData_metadata.data
};

void FileUploadData::registerTypes()
{
    qRegisterMetaType<FileUploadData>();
    qRegisterMetaType<FileUploadDataRepeated>();
}

FileUploadData::FileUploadData()
    : QProtobufMessage(&FileUploadData::staticMetaObject, &FileUploadData::staticPropertyOrdering),
      dptr(new FileUploadData_QtProtobufData)
{
}

FileUploadData::FileUploadData(const FileUploadData &other)
    = default;
FileUploadData &FileUploadData::operator =(const FileUploadData &other)
{
    FileUploadData temp(other);
    swap(temp);
    return *this;
}
FileUploadData::FileUploadData(FileUploadData &&other) noexcept
    = default;
bool comparesEqual(const FileUploadData &lhs, const FileUploadData &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_fileName == rhs.dptr->m_fileName
        && lhs.dptr->m_fileSize == rhs.dptr->m_fileSize
        && lhs.dptr->m_fileContent == rhs.dptr->m_fileContent;
}

const QString &FileUploadData::fileName() const &
{
    return dptr->m_fileName;
}

QtProtobuf::int64 FileUploadData::fileSize() const
{
    return dptr->m_fileSize;
}

const QByteArray &FileUploadData::fileContent() const &
{
    return dptr->m_fileContent;
}

void FileUploadData::setFileName(const QString &fileName)
{
    if (dptr->m_fileName != fileName) {
        dptr.detach();
        dptr->m_fileName = fileName;
    }
}

void FileUploadData::setFileName(QString &&fileName)
{
    if (dptr->m_fileName != fileName) {
        dptr.detach();
        dptr->m_fileName = std::move(fileName);
    }
}

void FileUploadData::setFileSize(QtProtobuf::int64 fileSize)
{
    if (dptr->m_fileSize != fileSize) {
        dptr.detach();
        dptr->m_fileSize = fileSize;
    }
}

void FileUploadData::setFileContent(const QByteArray &fileContent)
{
    if (dptr->m_fileContent != fileContent) {
        dptr.detach();
        dptr->m_fileContent = fileContent;
    }
}

void FileUploadData::setFileContent(QByteArray &&fileContent)
{
    if (dptr->m_fileContent != fileContent) {
        dptr.detach();
        dptr->m_fileContent = std::move(fileContent);
    }
}

} // namespace SnowK

#include "moc_base.qpb.cpp"
