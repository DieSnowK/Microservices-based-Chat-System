/* This file is autogenerated. DO NOT CHANGE. All changes will be lost */


#include "speech.qpb.h"

#include <QtProtobuf/qprotobufregistration.h>

#include <cmath>

namespace SnowK {

class SpeechRecognitionReq_QtProtobufData : public QSharedData
{
public:
    SpeechRecognitionReq_QtProtobufData()
        : QSharedData()
    {
    }

    SpeechRecognitionReq_QtProtobufData(const SpeechRecognitionReq_QtProtobufData &other)
        : QSharedData(other),
          m_requestId(other.m_requestId),
          m_speechContent(other.m_speechContent),
          m_userId(other.m_userId),
          m_sessionId(other.m_sessionId)
    {
    }

    QString m_requestId;
    QByteArray m_speechContent;
    std::optional<QString> m_userId;
    std::optional<QString> m_sessionId;
};

SpeechRecognitionReq::~SpeechRecognitionReq() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 17> qt_protobuf_SpeechRecognitionReq_uint_data;
    const char qt_protobuf_SpeechRecognitionReq_char_data[69];
} qt_protobuf_SpeechRecognitionReq_metadata {
    // data
    {
        0, /* = version */
        4, /* = num fields */
        5, /* = field number offset */
        9, /* = property index offset */
        13, /* = field flags offset */
        26, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        27, /* = requestId */
        37, /* = speechContent */
        51, /* = userId */
        58, /* = sessionId */
        68, /* = end-of-string-marker */
        // Field numbers:
        1, /* = requestId */
        2, /* = speechContent */
        3, /* = userId */
        4, /* = sessionId */
        // Property indices:
        0, /* = requestId */
        1, /* = speechContent */
        2, /* = userId */
        4, /* = sessionId */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = requestId */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = speechContent */
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = userId */
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = sessionId */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.SpeechRecognitionReq\0" /* = full message name */
    /* field char_data: */
    "requestId\0speechContent\0userId\0sessionId\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering SpeechRecognitionReq::staticPropertyOrdering = {
    &qt_protobuf_SpeechRecognitionReq_metadata.data
};

void SpeechRecognitionReq::registerTypes()
{
    qRegisterMetaType<SpeechRecognitionReq>();
    qRegisterMetaType<SpeechRecognitionReqRepeated>();
}

SpeechRecognitionReq::SpeechRecognitionReq()
    : QProtobufMessage(&SpeechRecognitionReq::staticMetaObject, &SpeechRecognitionReq::staticPropertyOrdering),
      dptr(new SpeechRecognitionReq_QtProtobufData)
{
}

SpeechRecognitionReq::SpeechRecognitionReq(const SpeechRecognitionReq &other)
    = default;
SpeechRecognitionReq &SpeechRecognitionReq::operator =(const SpeechRecognitionReq &other)
{
    SpeechRecognitionReq temp(other);
    swap(temp);
    return *this;
}
SpeechRecognitionReq::SpeechRecognitionReq(SpeechRecognitionReq &&other) noexcept
    = default;
bool comparesEqual(const SpeechRecognitionReq &lhs, const SpeechRecognitionReq &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_requestId == rhs.dptr->m_requestId
        && lhs.dptr->m_speechContent == rhs.dptr->m_speechContent
        && lhs.dptr->m_userId == rhs.dptr->m_userId
        && lhs.dptr->m_sessionId == rhs.dptr->m_sessionId;
}

const QString &SpeechRecognitionReq::requestId() const &
{
    return dptr->m_requestId;
}

const QByteArray &SpeechRecognitionReq::speechContent() const &
{
    return dptr->m_speechContent;
}

QString SpeechRecognitionReq::userId_p() const
{
    return dptr->m_userId ?
        dptr->m_userId.value() : QString();
}

bool SpeechRecognitionReq::hasUserId() const
{
    return dptr->m_userId.has_value();
}
QString SpeechRecognitionReq::userId() const
{
    Q_ASSERT(dptr->m_userId.has_value());
    return dptr->m_userId.value();
}

QString SpeechRecognitionReq::sessionId_p() const
{
    return dptr->m_sessionId ?
        dptr->m_sessionId.value() : QString();
}

bool SpeechRecognitionReq::hasSessionId() const
{
    return dptr->m_sessionId.has_value();
}
QString SpeechRecognitionReq::sessionId() const
{
    Q_ASSERT(dptr->m_sessionId.has_value());
    return dptr->m_sessionId.value();
}

void SpeechRecognitionReq::setRequestId(const QString &requestId)
{
    if (dptr->m_requestId != requestId) {
        dptr.detach();
        dptr->m_requestId = requestId;
    }
}

void SpeechRecognitionReq::setRequestId(QString &&requestId)
{
    if (dptr->m_requestId != requestId) {
        dptr.detach();
        dptr->m_requestId = std::move(requestId);
    }
}

void SpeechRecognitionReq::setSpeechContent(const QByteArray &speechContent)
{
    if (dptr->m_speechContent != speechContent) {
        dptr.detach();
        dptr->m_speechContent = speechContent;
    }
}

void SpeechRecognitionReq::setSpeechContent(QByteArray &&speechContent)
{
    if (dptr->m_speechContent != speechContent) {
        dptr.detach();
        dptr->m_speechContent = std::move(speechContent);
    }
}

void SpeechRecognitionReq::setUserId(const QString &userId)
{
    if (!dptr->m_userId || dptr->m_userId.value() != userId) {
        dptr.detach();
        dptr->m_userId = userId;
    }
}

void SpeechRecognitionReq::setUserId(QString &&userId)
{
    if (!dptr->m_userId || dptr->m_userId.value() != userId) {
        dptr.detach();
        dptr->m_userId = std::move(userId);
    }
}

void SpeechRecognitionReq::setUserId_p(QString userId)
{
    if (!dptr->m_userId || dptr->m_userId != userId) {
        dptr.detach();
        dptr->m_userId = userId;
    }
}

void SpeechRecognitionReq::clearUserId()
{
    if (dptr->m_userId.has_value()) {
        dptr.detach();
        dptr->m_userId.reset();
    }
}
void SpeechRecognitionReq::setSessionId(const QString &sessionId)
{
    if (!dptr->m_sessionId || dptr->m_sessionId.value() != sessionId) {
        dptr.detach();
        dptr->m_sessionId = sessionId;
    }
}

void SpeechRecognitionReq::setSessionId(QString &&sessionId)
{
    if (!dptr->m_sessionId || dptr->m_sessionId.value() != sessionId) {
        dptr.detach();
        dptr->m_sessionId = std::move(sessionId);
    }
}

void SpeechRecognitionReq::setSessionId_p(QString sessionId)
{
    if (!dptr->m_sessionId || dptr->m_sessionId != sessionId) {
        dptr.detach();
        dptr->m_sessionId = sessionId;
    }
}

void SpeechRecognitionReq::clearSessionId()
{
    if (dptr->m_sessionId.has_value()) {
        dptr.detach();
        dptr->m_sessionId.reset();
    }
}

class SpeechRecognitionRsp_QtProtobufData : public QSharedData
{
public:
    SpeechRecognitionRsp_QtProtobufData()
        : QSharedData(),
          m_success(false)
    {
    }

    SpeechRecognitionRsp_QtProtobufData(const SpeechRecognitionRsp_QtProtobufData &other)
        : QSharedData(other),
          m_requestId(other.m_requestId),
          m_success(other.m_success),
          m_errmsg(other.m_errmsg),
          m_recognitionResult(other.m_recognitionResult)
    {
    }

    QString m_requestId;
    bool m_success;
    std::optional<QString> m_errmsg;
    std::optional<QString> m_recognitionResult;
};

SpeechRecognitionRsp::~SpeechRecognitionRsp() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 17> qt_protobuf_SpeechRecognitionRsp_uint_data;
    const char qt_protobuf_SpeechRecognitionRsp_char_data[71];
} qt_protobuf_SpeechRecognitionRsp_metadata {
    // data
    {
        0, /* = version */
        4, /* = num fields */
        5, /* = field number offset */
        9, /* = property index offset */
        13, /* = field flags offset */
        26, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        27, /* = requestId */
        37, /* = success */
        45, /* = errmsg */
        52, /* = recognitionResult */
        70, /* = end-of-string-marker */
        // Field numbers:
        1, /* = requestId */
        2, /* = success */
        3, /* = errmsg */
        4, /* = recognitionResult */
        // Property indices:
        0, /* = requestId */
        1, /* = success */
        2, /* = errmsg */
        4, /* = recognitionResult */
        // Field flags:
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = requestId */
        uint(QtProtobufPrivate::FieldFlag::NoFlags), /* = success */
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = errmsg */
        uint(QtProtobufPrivate::FieldFlag::Optional | QtProtobufPrivate::FieldFlag::ExplicitPresence), /* = recognitionResult */
    },
    // char_data
    /* metadata char_data: */
    "SnowK.SpeechRecognitionRsp\0" /* = full message name */
    /* field char_data: */
    "requestId\0success\0errmsg\0recognitionResult\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering SpeechRecognitionRsp::staticPropertyOrdering = {
    &qt_protobuf_SpeechRecognitionRsp_metadata.data
};

void SpeechRecognitionRsp::registerTypes()
{
    qRegisterMetaType<SpeechRecognitionRsp>();
    qRegisterMetaType<SpeechRecognitionRspRepeated>();
}

SpeechRecognitionRsp::SpeechRecognitionRsp()
    : QProtobufMessage(&SpeechRecognitionRsp::staticMetaObject, &SpeechRecognitionRsp::staticPropertyOrdering),
      dptr(new SpeechRecognitionRsp_QtProtobufData)
{
}

SpeechRecognitionRsp::SpeechRecognitionRsp(const SpeechRecognitionRsp &other)
    = default;
SpeechRecognitionRsp &SpeechRecognitionRsp::operator =(const SpeechRecognitionRsp &other)
{
    SpeechRecognitionRsp temp(other);
    swap(temp);
    return *this;
}
SpeechRecognitionRsp::SpeechRecognitionRsp(SpeechRecognitionRsp &&other) noexcept
    = default;
bool comparesEqual(const SpeechRecognitionRsp &lhs, const SpeechRecognitionRsp &rhs) noexcept
{
    return operator ==(static_cast<const QProtobufMessage&>(lhs),
                       static_cast<const QProtobufMessage&>(rhs))
        && lhs.dptr->m_requestId == rhs.dptr->m_requestId
        && lhs.dptr->m_success == rhs.dptr->m_success
        && lhs.dptr->m_errmsg == rhs.dptr->m_errmsg
        && lhs.dptr->m_recognitionResult == rhs.dptr->m_recognitionResult;
}

const QString &SpeechRecognitionRsp::requestId() const &
{
    return dptr->m_requestId;
}

bool SpeechRecognitionRsp::success() const
{
    return dptr->m_success;
}

QString SpeechRecognitionRsp::errmsg_p() const
{
    return dptr->m_errmsg ?
        dptr->m_errmsg.value() : QString();
}

bool SpeechRecognitionRsp::hasErrmsg() const
{
    return dptr->m_errmsg.has_value();
}
QString SpeechRecognitionRsp::errmsg() const
{
    Q_ASSERT(dptr->m_errmsg.has_value());
    return dptr->m_errmsg.value();
}

QString SpeechRecognitionRsp::recognitionResult_p() const
{
    return dptr->m_recognitionResult ?
        dptr->m_recognitionResult.value() : QString();
}

bool SpeechRecognitionRsp::hasRecognitionResult() const
{
    return dptr->m_recognitionResult.has_value();
}
QString SpeechRecognitionRsp::recognitionResult() const
{
    Q_ASSERT(dptr->m_recognitionResult.has_value());
    return dptr->m_recognitionResult.value();
}

void SpeechRecognitionRsp::setRequestId(const QString &requestId)
{
    if (dptr->m_requestId != requestId) {
        dptr.detach();
        dptr->m_requestId = requestId;
    }
}

void SpeechRecognitionRsp::setRequestId(QString &&requestId)
{
    if (dptr->m_requestId != requestId) {
        dptr.detach();
        dptr->m_requestId = std::move(requestId);
    }
}

void SpeechRecognitionRsp::setSuccess(bool success)
{
    if (dptr->m_success != success) {
        dptr.detach();
        dptr->m_success = success;
    }
}

void SpeechRecognitionRsp::setErrmsg(const QString &errmsg)
{
    if (!dptr->m_errmsg || dptr->m_errmsg.value() != errmsg) {
        dptr.detach();
        dptr->m_errmsg = errmsg;
    }
}

void SpeechRecognitionRsp::setErrmsg(QString &&errmsg)
{
    if (!dptr->m_errmsg || dptr->m_errmsg.value() != errmsg) {
        dptr.detach();
        dptr->m_errmsg = std::move(errmsg);
    }
}

void SpeechRecognitionRsp::setErrmsg_p(QString errmsg)
{
    if (!dptr->m_errmsg || dptr->m_errmsg != errmsg) {
        dptr.detach();
        dptr->m_errmsg = errmsg;
    }
}

void SpeechRecognitionRsp::clearErrmsg()
{
    if (dptr->m_errmsg.has_value()) {
        dptr.detach();
        dptr->m_errmsg.reset();
    }
}
void SpeechRecognitionRsp::setRecognitionResult(const QString &recognitionResult)
{
    if (!dptr->m_recognitionResult || dptr->m_recognitionResult.value() != recognitionResult) {
        dptr.detach();
        dptr->m_recognitionResult = recognitionResult;
    }
}

void SpeechRecognitionRsp::setRecognitionResult(QString &&recognitionResult)
{
    if (!dptr->m_recognitionResult || dptr->m_recognitionResult.value() != recognitionResult) {
        dptr.detach();
        dptr->m_recognitionResult = std::move(recognitionResult);
    }
}

void SpeechRecognitionRsp::setRecognitionResult_p(QString recognitionResult)
{
    if (!dptr->m_recognitionResult || dptr->m_recognitionResult != recognitionResult) {
        dptr.detach();
        dptr->m_recognitionResult = recognitionResult;
    }
}

void SpeechRecognitionRsp::clearRecognitionResult()
{
    if (dptr->m_recognitionResult.has_value()) {
        dptr.detach();
        dptr->m_recognitionResult.reset();
    }
}
} // namespace SnowK

#include "moc_speech.qpb.cpp"
