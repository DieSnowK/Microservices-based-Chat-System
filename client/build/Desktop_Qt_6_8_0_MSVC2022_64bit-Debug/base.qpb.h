/* This file is autogenerated. DO NOT CHANGE. All changes will be lost */

#ifndef BASE_QPB_H
#define BASE_QPB_H

#include <QtProtobuf/qprotobuflazymessagepointer.h>
#include <QtProtobuf/qprotobufmessage.h>
#include <QtProtobuf/qprotobufobject.h>
#include <QtProtobuf/qprotobufoneof.h>
#include <QtProtobuf/qtprotobuftypes.h>

#include <QtCore/qbytearray.h>
#include <QtCore/qlist.h>
#include <QtCore/qmetatype.h>
#include <QtCore/qshareddata.h>
#include <QtCore/qstring.h>

#include <optional>

namespace SnowK {

namespace MessageTypeGadget {
Q_NAMESPACE

enum class MessageType : int32_t {
    STRING = 0,
    IMAGE = 1,
    FILE = 2,
    SPEECH = 3,
};
Q_ENUM_NS(MessageType)

using MessageTypeRepeated = QList<MessageType>;
void registerTypes();
} // namespace MessageTypeGadget
class UserInfo;
using UserInfoRepeated = QList<UserInfo>;
namespace UserInfo_QtProtobufNested {
enum class QtProtobufFieldEnum;
} // namespace UserInfo_QtProtobufNested

class ChatSessionInfo;
using ChatSessionInfoRepeated = QList<ChatSessionInfo>;
namespace ChatSessionInfo_QtProtobufNested {
enum class QtProtobufFieldEnum;
} // namespace ChatSessionInfo_QtProtobufNested

class StringMessageInfo;
using StringMessageInfoRepeated = QList<StringMessageInfo>;
namespace StringMessageInfo_QtProtobufNested {
enum class QtProtobufFieldEnum;
} // namespace StringMessageInfo_QtProtobufNested

class ImageMessageInfo;
using ImageMessageInfoRepeated = QList<ImageMessageInfo>;
namespace ImageMessageInfo_QtProtobufNested {
enum class QtProtobufFieldEnum;
} // namespace ImageMessageInfo_QtProtobufNested

class FileMessageInfo;
using FileMessageInfoRepeated = QList<FileMessageInfo>;
namespace FileMessageInfo_QtProtobufNested {
enum class QtProtobufFieldEnum;
} // namespace FileMessageInfo_QtProtobufNested

class SpeechMessageInfo;
using SpeechMessageInfoRepeated = QList<SpeechMessageInfo>;
namespace SpeechMessageInfo_QtProtobufNested {
enum class QtProtobufFieldEnum;
} // namespace SpeechMessageInfo_QtProtobufNested

class MessageContent;
using MessageContentRepeated = QList<MessageContent>;
namespace MessageContent_QtProtobufNested {
enum class QtProtobufFieldEnum;
enum class Msg_contentFields;
} // namespace MessageContent_QtProtobufNested

class MessageInfo;
using MessageInfoRepeated = QList<MessageInfo>;
namespace MessageInfo_QtProtobufNested {
enum class QtProtobufFieldEnum;
} // namespace MessageInfo_QtProtobufNested

class FileDownloadData;
using FileDownloadDataRepeated = QList<FileDownloadData>;
namespace FileDownloadData_QtProtobufNested {
enum class QtProtobufFieldEnum;
} // namespace FileDownloadData_QtProtobufNested

class FileUploadData;
using FileUploadDataRepeated = QList<FileUploadData>;
namespace FileUploadData_QtProtobufNested {
enum class QtProtobufFieldEnum;
} // namespace FileUploadData_QtProtobufNested


class UserInfo_QtProtobufData;
class UserInfo : public QProtobufMessage
{
    Q_PROTOBUF_OBJECT
    Q_PROPERTY(QString userId READ userId WRITE setUserId SCRIPTABLE true)
    Q_PROPERTY(QString nickname READ nickname WRITE setNickname SCRIPTABLE true)
    Q_PROPERTY(QString description READ description WRITE setDescription SCRIPTABLE true)
    Q_PROPERTY(QString phone READ phone WRITE setPhone SCRIPTABLE true)
    Q_PROPERTY(QByteArray avatar READ avatar WRITE setAvatar SCRIPTABLE true)

public:
    using QtProtobufFieldEnum = UserInfo_QtProtobufNested::QtProtobufFieldEnum;
    UserInfo();
    ~UserInfo();
    UserInfo(const UserInfo &other);
    UserInfo &operator =(const UserInfo &other);
    UserInfo(UserInfo &&other) noexcept;
    UserInfo &operator =(UserInfo &&other) noexcept
    {
        swap(other);
        return *this;
    }
    void swap(UserInfo &other) noexcept
    {
        QProtobufMessage::swap(other);
        dptr.swap(other.dptr);
    }

    const QString &userId() const &;

    const QString &nickname() const &;

    const QString &description() const &;

    const QString &phone() const &;

    const QByteArray &avatar() const &;
    void setUserId(const QString &userId);
    void setUserId(QString &&userId);
    void setNickname(const QString &nickname);
    void setNickname(QString &&nickname);
    void setDescription(const QString &description);
    void setDescription(QString &&description);
    void setPhone(const QString &phone);
    void setPhone(QString &&phone);
    void setAvatar(const QByteArray &avatar);
    void setAvatar(QByteArray &&avatar);
    static void registerTypes();

private:
    friend bool comparesEqual(const UserInfo &lhs, const UserInfo &rhs) noexcept;
    friend bool operator==(const UserInfo &lhs, const UserInfo &rhs) noexcept
    {
        return comparesEqual(lhs, rhs);
    }
    friend bool operator!=(const UserInfo &lhs, const UserInfo &rhs) noexcept
    {
        return !comparesEqual(lhs, rhs);
    }
    QExplicitlySharedDataPointer<UserInfo_QtProtobufData> dptr;
};
namespace UserInfo_QtProtobufNested {
Q_NAMESPACE

enum class QtProtobufFieldEnum {
    UserIdProtoFieldNumber = 1,
    NicknameProtoFieldNumber = 2,
    DescriptionProtoFieldNumber = 3,
    PhoneProtoFieldNumber = 4,
    AvatarProtoFieldNumber = 5,
};
Q_ENUM_NS(QtProtobufFieldEnum)

} // namespace UserInfo_QtProtobufNested

class ChatSessionInfo_QtProtobufData;
class ChatSessionInfo : public QProtobufMessage
{
    Q_PROTOBUF_OBJECT
    Q_PROPERTY(QString singleChatFriendId READ singleChatFriendId_p WRITE setSingleChatFriendId_p)
    Q_PROPERTY(bool hasSingleChatFriendId READ hasSingleChatFriendId)
    Q_PROPERTY(QString chatSessionId READ chatSessionId WRITE setChatSessionId SCRIPTABLE true)
    Q_PROPERTY(QString chatSessionName READ chatSessionName WRITE setChatSessionName SCRIPTABLE true)
    Q_PROPERTY(SnowK::MessageInfo *prevMessage_p READ prevMessage_p WRITE setPrevMessage_p SCRIPTABLE false)
    Q_PROPERTY(bool hasPrevMessage READ hasPrevMessage)
    Q_PROPERTY(QByteArray avatar READ avatar_p WRITE setAvatar_p)
    Q_PROPERTY(bool hasAvatar READ hasAvatar)

public:
    using QtProtobufFieldEnum = ChatSessionInfo_QtProtobufNested::QtProtobufFieldEnum;
    ChatSessionInfo();
    ~ChatSessionInfo();
    ChatSessionInfo(const ChatSessionInfo &other);
    ChatSessionInfo &operator =(const ChatSessionInfo &other);
    ChatSessionInfo(ChatSessionInfo &&other) noexcept;
    ChatSessionInfo &operator =(ChatSessionInfo &&other) noexcept
    {
        swap(other);
        return *this;
    }
    void swap(ChatSessionInfo &other) noexcept
    {
        QProtobufMessage::swap(other);
        dptr.swap(other.dptr);
    }

    bool hasSingleChatFriendId() const;
    QString singleChatFriendId() const;

    const QString &chatSessionId() const &;

    const QString &chatSessionName() const &;

    bool hasPrevMessage() const;
    const MessageInfo &prevMessage() const &;
    void clearPrevMessage();

    bool hasAvatar() const;
    QByteArray avatar() const;
    void setSingleChatFriendId(const QString &singleChatFriendId);
    void setSingleChatFriendId(QString &&singleChatFriendId);
    void clearSingleChatFriendId();
    void setChatSessionId(const QString &chatSessionId);
    void setChatSessionId(QString &&chatSessionId);
    void setChatSessionName(const QString &chatSessionName);
    void setChatSessionName(QString &&chatSessionName);
    void setPrevMessage(const MessageInfo &prevMessage);
    void setPrevMessage(MessageInfo &&prevMessage);
    void setAvatar(const QByteArray &avatar);
    void setAvatar(QByteArray &&avatar);
    void clearAvatar();
    static void registerTypes();

private:
    friend bool comparesEqual(const ChatSessionInfo &lhs, const ChatSessionInfo &rhs) noexcept;
    friend bool operator==(const ChatSessionInfo &lhs, const ChatSessionInfo &rhs) noexcept
    {
        return comparesEqual(lhs, rhs);
    }
    friend bool operator!=(const ChatSessionInfo &lhs, const ChatSessionInfo &rhs) noexcept
    {
        return !comparesEqual(lhs, rhs);
    }
    QString singleChatFriendId_p() const;
    MessageInfo *prevMessage_p();
    QByteArray avatar_p() const;
    void setSingleChatFriendId_p(QString singleChatFriendId);
    void setPrevMessage_p(MessageInfo *prevMessage);
    void setAvatar_p(QByteArray avatar);
    QExplicitlySharedDataPointer<ChatSessionInfo_QtProtobufData> dptr;
};
namespace ChatSessionInfo_QtProtobufNested {
Q_NAMESPACE

enum class QtProtobufFieldEnum {
    SingleChatFriendIdProtoFieldNumber = 1,
    ChatSessionIdProtoFieldNumber = 2,
    ChatSessionNameProtoFieldNumber = 3,
    PrevMessageProtoFieldNumber = 4,
    AvatarProtoFieldNumber = 5,
};
Q_ENUM_NS(QtProtobufFieldEnum)

} // namespace ChatSessionInfo_QtProtobufNested

class StringMessageInfo_QtProtobufData;
class StringMessageInfo : public QProtobufMessage
{
    Q_PROTOBUF_OBJECT
    Q_PROPERTY(QString content READ content WRITE setContent SCRIPTABLE true)

public:
    using QtProtobufFieldEnum = StringMessageInfo_QtProtobufNested::QtProtobufFieldEnum;
    StringMessageInfo();
    ~StringMessageInfo();
    StringMessageInfo(const StringMessageInfo &other);
    StringMessageInfo &operator =(const StringMessageInfo &other);
    StringMessageInfo(StringMessageInfo &&other) noexcept;
    StringMessageInfo &operator =(StringMessageInfo &&other) noexcept
    {
        swap(other);
        return *this;
    }
    void swap(StringMessageInfo &other) noexcept
    {
        QProtobufMessage::swap(other);
        dptr.swap(other.dptr);
    }

    const QString &content() const &;
    void setContent(const QString &content);
    void setContent(QString &&content);
    static void registerTypes();

private:
    friend bool comparesEqual(const StringMessageInfo &lhs, const StringMessageInfo &rhs) noexcept;
    friend bool operator==(const StringMessageInfo &lhs, const StringMessageInfo &rhs) noexcept
    {
        return comparesEqual(lhs, rhs);
    }
    friend bool operator!=(const StringMessageInfo &lhs, const StringMessageInfo &rhs) noexcept
    {
        return !comparesEqual(lhs, rhs);
    }
    QExplicitlySharedDataPointer<StringMessageInfo_QtProtobufData> dptr;
};
namespace StringMessageInfo_QtProtobufNested {
Q_NAMESPACE

enum class QtProtobufFieldEnum {
    ContentProtoFieldNumber = 1,
};
Q_ENUM_NS(QtProtobufFieldEnum)

} // namespace StringMessageInfo_QtProtobufNested

class ImageMessageInfo_QtProtobufData;
class ImageMessageInfo : public QProtobufMessage
{
    Q_PROTOBUF_OBJECT
    Q_PROPERTY(QString fileId READ fileId_p WRITE setFileId_p)
    Q_PROPERTY(bool hasFileId READ hasFileId)
    Q_PROPERTY(QByteArray imageContent READ imageContent_p WRITE setImageContent_p)
    Q_PROPERTY(bool hasImageContent READ hasImageContent)

public:
    using QtProtobufFieldEnum = ImageMessageInfo_QtProtobufNested::QtProtobufFieldEnum;
    ImageMessageInfo();
    ~ImageMessageInfo();
    ImageMessageInfo(const ImageMessageInfo &other);
    ImageMessageInfo &operator =(const ImageMessageInfo &other);
    ImageMessageInfo(ImageMessageInfo &&other) noexcept;
    ImageMessageInfo &operator =(ImageMessageInfo &&other) noexcept
    {
        swap(other);
        return *this;
    }
    void swap(ImageMessageInfo &other) noexcept
    {
        QProtobufMessage::swap(other);
        dptr.swap(other.dptr);
    }

    bool hasFileId() const;
    QString fileId() const;

    bool hasImageContent() const;
    QByteArray imageContent() const;
    void setFileId(const QString &fileId);
    void setFileId(QString &&fileId);
    void clearFileId();
    void setImageContent(const QByteArray &imageContent);
    void setImageContent(QByteArray &&imageContent);
    void clearImageContent();
    static void registerTypes();

private:
    friend bool comparesEqual(const ImageMessageInfo &lhs, const ImageMessageInfo &rhs) noexcept;
    friend bool operator==(const ImageMessageInfo &lhs, const ImageMessageInfo &rhs) noexcept
    {
        return comparesEqual(lhs, rhs);
    }
    friend bool operator!=(const ImageMessageInfo &lhs, const ImageMessageInfo &rhs) noexcept
    {
        return !comparesEqual(lhs, rhs);
    }
    QString fileId_p() const;
    QByteArray imageContent_p() const;
    void setFileId_p(QString fileId);
    void setImageContent_p(QByteArray imageContent);
    QExplicitlySharedDataPointer<ImageMessageInfo_QtProtobufData> dptr;
};
namespace ImageMessageInfo_QtProtobufNested {
Q_NAMESPACE

enum class QtProtobufFieldEnum {
    FileIdProtoFieldNumber = 1,
    ImageContentProtoFieldNumber = 2,
};
Q_ENUM_NS(QtProtobufFieldEnum)

} // namespace ImageMessageInfo_QtProtobufNested

class FileMessageInfo_QtProtobufData;
class FileMessageInfo : public QProtobufMessage
{
    Q_PROTOBUF_OBJECT
    Q_PROPERTY(QString fileId READ fileId_p WRITE setFileId_p)
    Q_PROPERTY(bool hasFileId READ hasFileId)
    Q_PROPERTY(QtProtobuf::int64 fileSize READ fileSize_p WRITE setFileSize_p)
    Q_PROPERTY(bool hasFileSize READ hasFileSize)
    Q_PROPERTY(QString fileName READ fileName_p WRITE setFileName_p)
    Q_PROPERTY(bool hasFileName READ hasFileName)
    Q_PROPERTY(QByteArray fileContents READ fileContents_p WRITE setFileContents_p)
    Q_PROPERTY(bool hasFileContents READ hasFileContents)

public:
    using QtProtobufFieldEnum = FileMessageInfo_QtProtobufNested::QtProtobufFieldEnum;
    FileMessageInfo();
    ~FileMessageInfo();
    FileMessageInfo(const FileMessageInfo &other);
    FileMessageInfo &operator =(const FileMessageInfo &other);
    FileMessageInfo(FileMessageInfo &&other) noexcept;
    FileMessageInfo &operator =(FileMessageInfo &&other) noexcept
    {
        swap(other);
        return *this;
    }
    void swap(FileMessageInfo &other) noexcept
    {
        QProtobufMessage::swap(other);
        dptr.swap(other.dptr);
    }

    bool hasFileId() const;
    QString fileId() const;

    bool hasFileSize() const;
    QtProtobuf::int64 fileSize() const;

    bool hasFileName() const;
    QString fileName() const;

    bool hasFileContents() const;
    QByteArray fileContents() const;
    void setFileId(const QString &fileId);
    void setFileId(QString &&fileId);
    void clearFileId();
    void setFileSize(QtProtobuf::int64 fileSize);
    void clearFileSize();
    void setFileName(const QString &fileName);
    void setFileName(QString &&fileName);
    void clearFileName();
    void setFileContents(const QByteArray &fileContents);
    void setFileContents(QByteArray &&fileContents);
    void clearFileContents();
    static void registerTypes();

private:
    friend bool comparesEqual(const FileMessageInfo &lhs, const FileMessageInfo &rhs) noexcept;
    friend bool operator==(const FileMessageInfo &lhs, const FileMessageInfo &rhs) noexcept
    {
        return comparesEqual(lhs, rhs);
    }
    friend bool operator!=(const FileMessageInfo &lhs, const FileMessageInfo &rhs) noexcept
    {
        return !comparesEqual(lhs, rhs);
    }
    QString fileId_p() const;
    QtProtobuf::int64 fileSize_p() const;
    QString fileName_p() const;
    QByteArray fileContents_p() const;
    void setFileId_p(QString fileId);
    void setFileSize_p(QtProtobuf::int64 fileSize);
    void setFileName_p(QString fileName);
    void setFileContents_p(QByteArray fileContents);
    QExplicitlySharedDataPointer<FileMessageInfo_QtProtobufData> dptr;
};
namespace FileMessageInfo_QtProtobufNested {
Q_NAMESPACE

enum class QtProtobufFieldEnum {
    FileIdProtoFieldNumber = 1,
    FileSizeProtoFieldNumber = 2,
    FileNameProtoFieldNumber = 3,
    FileContentsProtoFieldNumber = 4,
};
Q_ENUM_NS(QtProtobufFieldEnum)

} // namespace FileMessageInfo_QtProtobufNested

class SpeechMessageInfo_QtProtobufData;
class SpeechMessageInfo : public QProtobufMessage
{
    Q_PROTOBUF_OBJECT
    Q_PROPERTY(QString fileId READ fileId_p WRITE setFileId_p)
    Q_PROPERTY(bool hasFileId READ hasFileId)
    Q_PROPERTY(QByteArray fileContents READ fileContents_p WRITE setFileContents_p)
    Q_PROPERTY(bool hasFileContents READ hasFileContents)

public:
    using QtProtobufFieldEnum = SpeechMessageInfo_QtProtobufNested::QtProtobufFieldEnum;
    SpeechMessageInfo();
    ~SpeechMessageInfo();
    SpeechMessageInfo(const SpeechMessageInfo &other);
    SpeechMessageInfo &operator =(const SpeechMessageInfo &other);
    SpeechMessageInfo(SpeechMessageInfo &&other) noexcept;
    SpeechMessageInfo &operator =(SpeechMessageInfo &&other) noexcept
    {
        swap(other);
        return *this;
    }
    void swap(SpeechMessageInfo &other) noexcept
    {
        QProtobufMessage::swap(other);
        dptr.swap(other.dptr);
    }

    bool hasFileId() const;
    QString fileId() const;

    bool hasFileContents() const;
    QByteArray fileContents() const;
    void setFileId(const QString &fileId);
    void setFileId(QString &&fileId);
    void clearFileId();
    void setFileContents(const QByteArray &fileContents);
    void setFileContents(QByteArray &&fileContents);
    void clearFileContents();
    static void registerTypes();

private:
    friend bool comparesEqual(const SpeechMessageInfo &lhs, const SpeechMessageInfo &rhs) noexcept;
    friend bool operator==(const SpeechMessageInfo &lhs, const SpeechMessageInfo &rhs) noexcept
    {
        return comparesEqual(lhs, rhs);
    }
    friend bool operator!=(const SpeechMessageInfo &lhs, const SpeechMessageInfo &rhs) noexcept
    {
        return !comparesEqual(lhs, rhs);
    }
    QString fileId_p() const;
    QByteArray fileContents_p() const;
    void setFileId_p(QString fileId);
    void setFileContents_p(QByteArray fileContents);
    QExplicitlySharedDataPointer<SpeechMessageInfo_QtProtobufData> dptr;
};
namespace SpeechMessageInfo_QtProtobufNested {
Q_NAMESPACE

enum class QtProtobufFieldEnum {
    FileIdProtoFieldNumber = 1,
    FileContentsProtoFieldNumber = 2,
};
Q_ENUM_NS(QtProtobufFieldEnum)

} // namespace SpeechMessageInfo_QtProtobufNested

class MessageContent_QtProtobufData;
class MessageContent : public QProtobufMessage
{
    Q_PROTOBUF_OBJECT
    Q_PROPERTY(SnowK::MessageTypeGadget::MessageType messageType READ messageType WRITE setMessageType SCRIPTABLE true)
    Q_PROPERTY(SnowK::StringMessageInfo *stringMessage_p READ stringMessage_p WRITE setStringMessage_p SCRIPTABLE false)
    Q_PROPERTY(bool hasStringMessage READ hasStringMessage)
    Q_PROPERTY(SnowK::FileMessageInfo *fileMessage_p READ fileMessage_p WRITE setFileMessage_p SCRIPTABLE false)
    Q_PROPERTY(bool hasFileMessage READ hasFileMessage)
    Q_PROPERTY(SnowK::SpeechMessageInfo *speechMessage_p READ speechMessage_p WRITE setSpeechMessage_p SCRIPTABLE false)
    Q_PROPERTY(bool hasSpeechMessage READ hasSpeechMessage)
    Q_PROPERTY(SnowK::ImageMessageInfo *imageMessage_p READ imageMessage_p WRITE setImageMessage_p SCRIPTABLE false)
    Q_PROPERTY(bool hasImageMessage READ hasImageMessage)

public:
    using QtProtobufFieldEnum = MessageContent_QtProtobufNested::QtProtobufFieldEnum;
    using Msg_contentFields = MessageContent_QtProtobufNested::Msg_contentFields;
    MessageContent();
    ~MessageContent();
    MessageContent(const MessageContent &other);
    MessageContent &operator =(const MessageContent &other);
    MessageContent(MessageContent &&other) noexcept;
    MessageContent &operator =(MessageContent &&other) noexcept
    {
        swap(other);
        return *this;
    }
    void swap(MessageContent &other) noexcept
    {
        QProtobufMessage::swap(other);
        dptr.swap(other.dptr);
    }

    MessageTypeGadget::MessageType messageType() const;

    bool hasStringMessage() const;
    StringMessageInfo &stringMessage() const;

    bool hasFileMessage() const;
    FileMessageInfo &fileMessage() const;

    bool hasSpeechMessage() const;
    SpeechMessageInfo &speechMessage() const;

    bool hasImageMessage() const;
    ImageMessageInfo &imageMessage() const;
    Msg_contentFields msg_contentField() const;
    void setMessageType(MessageTypeGadget::MessageType messageType);
    void setStringMessage(const StringMessageInfo &stringMessage);
    void setStringMessage(StringMessageInfo &&stringMessage);
    void setFileMessage(const FileMessageInfo &fileMessage);
    void setFileMessage(FileMessageInfo &&fileMessage);
    void setSpeechMessage(const SpeechMessageInfo &speechMessage);
    void setSpeechMessage(SpeechMessageInfo &&speechMessage);
    void setImageMessage(const ImageMessageInfo &imageMessage);
    void setImageMessage(ImageMessageInfo &&imageMessage);
    void clearMsg_content();
    static void registerTypes();

private:
    friend bool comparesEqual(const MessageContent &lhs, const MessageContent &rhs) noexcept;
    friend bool operator==(const MessageContent &lhs, const MessageContent &rhs) noexcept
    {
        return comparesEqual(lhs, rhs);
    }
    friend bool operator!=(const MessageContent &lhs, const MessageContent &rhs) noexcept
    {
        return !comparesEqual(lhs, rhs);
    }
    StringMessageInfo *stringMessage_p();
    FileMessageInfo *fileMessage_p();
    SpeechMessageInfo *speechMessage_p();
    ImageMessageInfo *imageMessage_p();
    void setStringMessage_p(StringMessageInfo *stringMessage);
    void setFileMessage_p(FileMessageInfo *fileMessage);
    void setSpeechMessage_p(SpeechMessageInfo *speechMessage);
    void setImageMessage_p(ImageMessageInfo *imageMessage);
    QExplicitlySharedDataPointer<MessageContent_QtProtobufData> dptr;
};
namespace MessageContent_QtProtobufNested {
Q_NAMESPACE

enum class QtProtobufFieldEnum {
    MessageTypeProtoFieldNumber = 1,
    StringMessageProtoFieldNumber = 2,
    FileMessageProtoFieldNumber = 3,
    SpeechMessageProtoFieldNumber = 4,
    ImageMessageProtoFieldNumber = 5,
};
Q_ENUM_NS(QtProtobufFieldEnum)

enum class Msg_contentFields : int32_t {
    UninitializedField = QtProtobuf::InvalidFieldNumber,
    StringMessage = 2,
    FileMessage = 3,
    SpeechMessage = 4,
    ImageMessage = 5,
};
Q_ENUM_NS(Msg_contentFields)

} // namespace MessageContent_QtProtobufNested

class MessageInfo_QtProtobufData;
class MessageInfo : public QProtobufMessage
{
    Q_PROTOBUF_OBJECT
    Q_PROPERTY(QString messageId READ messageId WRITE setMessageId SCRIPTABLE true)
    Q_PROPERTY(QString chatSessionId READ chatSessionId WRITE setChatSessionId SCRIPTABLE true)
    Q_PROPERTY(QtProtobuf::int64 timestamp READ timestamp WRITE setTimestamp SCRIPTABLE false)
    Q_PROPERTY(SnowK::UserInfo *sender_p READ sender_p WRITE setSender_p SCRIPTABLE false)
    Q_PROPERTY(bool hasSender READ hasSender)
    Q_PROPERTY(SnowK::MessageContent *message_p READ message_p WRITE setMessage_p SCRIPTABLE false)
    Q_PROPERTY(bool hasMessage READ hasMessage)

public:
    using QtProtobufFieldEnum = MessageInfo_QtProtobufNested::QtProtobufFieldEnum;
    MessageInfo();
    ~MessageInfo();
    MessageInfo(const MessageInfo &other);
    MessageInfo &operator =(const MessageInfo &other);
    MessageInfo(MessageInfo &&other) noexcept;
    MessageInfo &operator =(MessageInfo &&other) noexcept
    {
        swap(other);
        return *this;
    }
    void swap(MessageInfo &other) noexcept
    {
        QProtobufMessage::swap(other);
        dptr.swap(other.dptr);
    }

    const QString &messageId() const &;

    const QString &chatSessionId() const &;

    QtProtobuf::int64 timestamp() const;

    bool hasSender() const;
    const UserInfo &sender() const &;
    void clearSender();

    bool hasMessage() const;
    const MessageContent &message() const &;
    void clearMessage();
    void setMessageId(const QString &messageId);
    void setMessageId(QString &&messageId);
    void setChatSessionId(const QString &chatSessionId);
    void setChatSessionId(QString &&chatSessionId);
    void setTimestamp(QtProtobuf::int64 timestamp);
    void setSender(const UserInfo &sender);
    void setSender(UserInfo &&sender);
    void setMessage(const MessageContent &message);
    void setMessage(MessageContent &&message);
    static void registerTypes();

private:
    friend bool comparesEqual(const MessageInfo &lhs, const MessageInfo &rhs) noexcept;
    friend bool operator==(const MessageInfo &lhs, const MessageInfo &rhs) noexcept
    {
        return comparesEqual(lhs, rhs);
    }
    friend bool operator!=(const MessageInfo &lhs, const MessageInfo &rhs) noexcept
    {
        return !comparesEqual(lhs, rhs);
    }
    UserInfo *sender_p();
    MessageContent *message_p();
    void setSender_p(UserInfo *sender);
    void setMessage_p(MessageContent *message);
    QExplicitlySharedDataPointer<MessageInfo_QtProtobufData> dptr;
};
namespace MessageInfo_QtProtobufNested {
Q_NAMESPACE

enum class QtProtobufFieldEnum {
    MessageIdProtoFieldNumber = 1,
    ChatSessionIdProtoFieldNumber = 2,
    TimestampProtoFieldNumber = 3,
    SenderProtoFieldNumber = 4,
    MessageProtoFieldNumber = 5,
};
Q_ENUM_NS(QtProtobufFieldEnum)

} // namespace MessageInfo_QtProtobufNested

class FileDownloadData_QtProtobufData;
class FileDownloadData : public QProtobufMessage
{
    Q_PROTOBUF_OBJECT
    Q_PROPERTY(QString fileId READ fileId WRITE setFileId SCRIPTABLE true)
    Q_PROPERTY(QByteArray fileContent READ fileContent WRITE setFileContent SCRIPTABLE true)

public:
    using QtProtobufFieldEnum = FileDownloadData_QtProtobufNested::QtProtobufFieldEnum;
    FileDownloadData();
    ~FileDownloadData();
    FileDownloadData(const FileDownloadData &other);
    FileDownloadData &operator =(const FileDownloadData &other);
    FileDownloadData(FileDownloadData &&other) noexcept;
    FileDownloadData &operator =(FileDownloadData &&other) noexcept
    {
        swap(other);
        return *this;
    }
    void swap(FileDownloadData &other) noexcept
    {
        QProtobufMessage::swap(other);
        dptr.swap(other.dptr);
    }

    const QString &fileId() const &;

    const QByteArray &fileContent() const &;
    void setFileId(const QString &fileId);
    void setFileId(QString &&fileId);
    void setFileContent(const QByteArray &fileContent);
    void setFileContent(QByteArray &&fileContent);
    static void registerTypes();

private:
    friend bool comparesEqual(const FileDownloadData &lhs, const FileDownloadData &rhs) noexcept;
    friend bool operator==(const FileDownloadData &lhs, const FileDownloadData &rhs) noexcept
    {
        return comparesEqual(lhs, rhs);
    }
    friend bool operator!=(const FileDownloadData &lhs, const FileDownloadData &rhs) noexcept
    {
        return !comparesEqual(lhs, rhs);
    }
    QExplicitlySharedDataPointer<FileDownloadData_QtProtobufData> dptr;
};
namespace FileDownloadData_QtProtobufNested {
Q_NAMESPACE

enum class QtProtobufFieldEnum {
    FileIdProtoFieldNumber = 1,
    FileContentProtoFieldNumber = 2,
};
Q_ENUM_NS(QtProtobufFieldEnum)

} // namespace FileDownloadData_QtProtobufNested

class FileUploadData_QtProtobufData;
class FileUploadData : public QProtobufMessage
{
    Q_PROTOBUF_OBJECT
    Q_PROPERTY(QString fileName READ fileName WRITE setFileName SCRIPTABLE true)
    Q_PROPERTY(QtProtobuf::int64 fileSize READ fileSize WRITE setFileSize SCRIPTABLE false)
    Q_PROPERTY(QByteArray fileContent READ fileContent WRITE setFileContent SCRIPTABLE true)

public:
    using QtProtobufFieldEnum = FileUploadData_QtProtobufNested::QtProtobufFieldEnum;
    FileUploadData();
    ~FileUploadData();
    FileUploadData(const FileUploadData &other);
    FileUploadData &operator =(const FileUploadData &other);
    FileUploadData(FileUploadData &&other) noexcept;
    FileUploadData &operator =(FileUploadData &&other) noexcept
    {
        swap(other);
        return *this;
    }
    void swap(FileUploadData &other) noexcept
    {
        QProtobufMessage::swap(other);
        dptr.swap(other.dptr);
    }

    const QString &fileName() const &;

    QtProtobuf::int64 fileSize() const;

    const QByteArray &fileContent() const &;
    void setFileName(const QString &fileName);
    void setFileName(QString &&fileName);
    void setFileSize(QtProtobuf::int64 fileSize);
    void setFileContent(const QByteArray &fileContent);
    void setFileContent(QByteArray &&fileContent);
    static void registerTypes();

private:
    friend bool comparesEqual(const FileUploadData &lhs, const FileUploadData &rhs) noexcept;
    friend bool operator==(const FileUploadData &lhs, const FileUploadData &rhs) noexcept
    {
        return comparesEqual(lhs, rhs);
    }
    friend bool operator!=(const FileUploadData &lhs, const FileUploadData &rhs) noexcept
    {
        return !comparesEqual(lhs, rhs);
    }
    QExplicitlySharedDataPointer<FileUploadData_QtProtobufData> dptr;
};
namespace FileUploadData_QtProtobufNested {
Q_NAMESPACE

enum class QtProtobufFieldEnum {
    FileNameProtoFieldNumber = 1,
    FileSizeProtoFieldNumber = 2,
    FileContentProtoFieldNumber = 3,
};
Q_ENUM_NS(QtProtobufFieldEnum)

} // namespace FileUploadData_QtProtobufNested
} // namespace SnowK

#endif // BASE_QPB_H
